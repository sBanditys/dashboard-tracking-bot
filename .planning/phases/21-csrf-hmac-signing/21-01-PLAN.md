---
phase: 21-csrf-hmac-signing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/proxy.ts
autonomous: true
requirements:
  - AUTH-01

must_haves:
  truths:
    - "A mutation proxied through middleware sends an HMAC-signed CSRF token (randomValue.hmac format) when CSRF_HMAC_SECRET is configured and user is authenticated"
    - "When CSRF_HMAC_SECRET is not set, middleware falls back to plain random tokens (current UUID-style behavior) without errors"
    - "The HMAC signature is computed over jti:randomValue using the shared secret, matching the backend csrf.ts contract exactly"
    - "The existing double-submit cookie check (cookie === header) remains intact and runs before HMAC generation"
  artifacts:
    - path: "src/proxy.ts"
      provides: "HMAC CSRF token generation, JTI extraction, async token flow"
      contains: "generateHmacCsrfToken"
  key_links:
    - from: "src/proxy.ts (generateHmacCsrfToken)"
      to: "backend csrf.ts (validateHmacCsrfToken)"
      via: "HMAC-SHA256 over jti:randomValue with shared CSRF_HMAC_SECRET"
      pattern: "crypto\\.subtle\\.sign"
    - from: "src/proxy.ts (extractJtiFromAuthToken)"
      to: "request.cookies auth_token"
      via: "JWT payload parsing for jti field"
      pattern: "cookies\\.get\\('auth_token'\\)"
    - from: "src/proxy.ts (setCsrfCookie call)"
      to: "generateHmacCsrfToken"
      via: "await at line 203 call site"
      pattern: "await generateHmacCsrfToken"
---

<objective>
Upgrade proxy.ts CSRF token generation from plain `crypto.randomUUID()` to HMAC-signed tokens using `crypto.subtle` and a shared secret, matching the backend Phase 37 HMAC validation contract.

Purpose: Session-bind CSRF tokens so a stolen cookie cannot forge a valid token without the HMAC secret. Defense in depth on top of existing double-submit check.
Output: Updated `src/proxy.ts` with HMAC token generation, JTI extraction, and graceful fallback.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-csrf-hmac-signing/21-CONTEXT.md
@.planning/phases/21-csrf-hmac-signing/21-RESEARCH.md
@src/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HMAC token generation and JTI extraction to proxy.ts</name>
  <files>src/proxy.ts</files>
  <action>
Add three things to `src/proxy.ts`, all ABOVE the existing `setCsrfCookie` function:

1. **Secret constant** (after line 12, near other constants):
```typescript
// CSRF HMAC secret — must match backend's CSRF_HMAC_SECRET env var.
// Falls back to INTERNAL_API_SECRET for backward compatibility with CONTEXT.md spec.
const CSRF_HMAC_SECRET = (process.env.CSRF_HMAC_SECRET || process.env.INTERNAL_API_SECRET || '').trim();
```

2. **`extractJtiFromAuthToken` function** — Extract JTI from the dashboard's `auth_token` cookie (JWT). Mirrors backend `extractJtiFromAccessToken` from csrf.ts lines 65-78.
- Read `request.cookies.get('auth_token')?.value` (dashboard local cookie name, NOT `dashboard_at`)
- Split JWT on `.`, decode base64url payload (replace `-` with `+`, `_` with `/`, then `Buffer.from(base64, 'base64').toString('utf-8')`)
- Parse JSON, return `payload.jti` if string, else `null`
- Wrap in try/catch, return `null` on any error
- Parameter: `request: NextRequest`
- Return type: `string | null`

3. **`generateHmacCsrfToken` function** — Generate HMAC-signed CSRF token matching backend contract.
- Generate 32 random bytes using `crypto.getRandomValues(new Uint8Array(32))`
- Convert to 64-char hex string (the `randomValue`)
- If no `jti` or no `CSRF_HMAC_SECRET`, return just `randomValue` (graceful fallback to plain token)
- Otherwise: import key via `crypto.subtle.importKey('raw', encoded_secret, {name: 'HMAC', hash: 'SHA-256'}, false, ['sign'])`
- Sign payload `${jti}:${randomValue}` via `crypto.subtle.sign('HMAC', key, encoded_payload)`
- Convert signature to 64-char hex string (the `hmac`)
- Return `${randomValue}.${hmac}` (129 chars total — matches backend format exactly)
- Parameter: `jti: string | null`
- Return type: `Promise<string>`
- Mark as `async`

**Do NOT:**
- Import `node:crypto` or `crypto` module — use global `crypto.subtle` and `crypto.getRandomValues`
- Cache the CryptoKey in module scope (per-request import is safe and avoids secret rotation issues)
- Add any logging for successful token generation (silent operation per locked decision)
- Modify or remove the existing `setCsrfCookie` function — it stays as-is
- Modify or remove the existing double-submit cookie check (lines 130-140) — it stays as-is (belt-and-suspenders per locked decision)

**Token format contract (MUST match exactly):**
```
Token = randomValue + "." + hmac
randomValue = 64-char hex (32 random bytes)
hmac = HMAC-SHA256(key=CSRF_HMAC_SECRET, message="jti:randomValue") as 64-char hex
Total = 129 chars when HMAC is present
```

Hex encoding pattern: `Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('')`
  </action>
  <verify>
    <automated>cd /Users/gabrielleal/Desktop/dashboard-tracking-bot && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify proxy.ts contains generateHmacCsrfToken and extractJtiFromAuthToken functions, CSRF_HMAC_SECRET constant, and that setCsrfCookie and double-submit check are unchanged</manual>
  </verify>
  <done>proxy.ts has generateHmacCsrfToken (async, returns randomValue.hmac or plain randomValue), extractJtiFromAuthToken (parses auth_token JWT for jti), and CSRF_HMAC_SECRET constant. Existing setCsrfCookie and double-submit check are unchanged. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Wire HMAC token generation into the CSRF cookie call site</name>
  <files>src/proxy.ts</files>
  <action>
Update the single CSRF token generation call site at line 203 of proxy.ts:

**Replace:**
```typescript
setCsrfCookie(response, crypto.randomUUID());
```

**With:**
```typescript
const jti = extractJtiFromAuthToken(request);
const csrfToken = await generateHmacCsrfToken(jti);
setCsrfCookie(response, csrfToken);
```

The `proxy` function is already `async` (line 113: `export async function proxy(request: NextRequest)`), so `await` works without signature changes.

**Verify these things are STILL true after the change:**
- The double-submit cookie check at lines 130-140 is unchanged (reads `csrf_token` cookie and `X-CSRF-Token` header, compares for equality)
- `setCsrfCookie` still sets the cookie with `httpOnly: false` (client JS must read it to send in header)
- No other call sites for `crypto.randomUUID()` are affected (the nonce at line 117 and requestId at line 118 remain as UUID)
- The `refreshTokensFromMiddleware` function (lines 69-74) still forwards the existing csrf_token cookie — it reads whatever is in the cookie already, which is now an HMAC-signed token. No change needed there.

**Do NOT:**
- Add any feature flag or environment toggle — ship HMAC immediately (per locked decision)
- Add logging for the token generation path
- Modify the nonce or requestId UUID generation
- Change any other line in the proxy function
  </action>
  <verify>
    <automated>cd /Users/gabrielleal/Desktop/dashboard-tracking-bot && npx tsc --noEmit 2>&1 | head -30 && grep -n 'crypto.randomUUID' src/proxy.ts | head -10 && grep -n 'generateHmacCsrfToken\|extractJtiFromAuthToken\|CSRF_HMAC_SECRET' src/proxy.ts | head -10</automated>
    <manual>Verify that crypto.randomUUID appears only for nonce and requestId (2 occurrences), NOT for CSRF token. Verify generateHmacCsrfToken is called with await at the old line 203 location.</manual>
  </verify>
  <done>The CSRF cookie call site uses await generateHmacCsrfToken(jti) instead of crypto.randomUUID(). crypto.randomUUID() only appears for nonce and requestId (2 occurrences). TypeScript compiles clean. Double-submit check unchanged. refreshTokensFromMiddleware cookie forwarding unchanged.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -c 'crypto.randomUUID' src/proxy.ts` returns exactly 2 (nonce + requestId, NOT csrf)
3. `grep 'generateHmacCsrfToken' src/proxy.ts` shows the function definition and the call site
4. `grep 'extractJtiFromAuthToken' src/proxy.ts` shows the function definition and the call site
5. `grep 'CSRF_HMAC_SECRET' src/proxy.ts` shows the constant with fallback chain
6. `grep 'cookieToken !== headerToken' src/proxy.ts` confirms double-submit check is unchanged
7. `grep "httpOnly: false" src/proxy.ts` confirms client-readable CSRF cookie is unchanged
</verification>

<success_criteria>
- proxy.ts generates HMAC-signed CSRF tokens (randomValue.hmac format) when CSRF_HMAC_SECRET is set and user is authenticated
- proxy.ts falls back to plain random tokens when secret is missing or user is not authenticated (no auth_token cookie)
- Existing double-submit cookie validation is unchanged
- Existing CSRF retry in fetch-with-retry.ts works without modification (it already handles 403 + EBADCSRFTOKEN)
- TypeScript compiles with zero errors
- No new npm dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/21-csrf-hmac-signing/21-01-SUMMARY.md`
</output>
