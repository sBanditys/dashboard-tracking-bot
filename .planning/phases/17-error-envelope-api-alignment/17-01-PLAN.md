---
phase: 17-error-envelope-api-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/server/error-sanitizer.ts
  - src/lib/api-error.ts
  - src/lib/fetch-with-retry.ts
  - src/proxy.ts
autonomous: true
requirements:
  - ERR-01
  - ERR-02
  - ERR-03

must_haves:
  truths:
    - "Backend errors in new envelope shape { error: { code, message } } are correctly extracted by the sanitizer and produce readable SanitizedError output"
    - "Backend errors in old envelope shape { error: string, code? } continue to work exactly as before"
    - "The unverified_email code is detected from both old and new envelope shapes, triggering the email-verification redirect"
    - "EBADCSRFTOKEN code is detected from both old and new envelope shapes, triggering the CSRF retry loop"
    - "The CSRF cookie is named csrf_token everywhere — proxy sets it, proxy validates it, fetchWithRetry reads it"
    - "A shared parseApiError helper extracts error messages from proxy responses using the correct .error field"
  artifacts:
    - path: "src/lib/server/error-sanitizer.ts"
      provides: "Dual-envelope type guard and extraction"
      contains: "isNewEnvelope"
    - path: "src/lib/api-error.ts"
      provides: "Client-side error extraction from proxy responses"
      exports: ["parseApiError"]
    - path: "src/lib/fetch-with-retry.ts"
      provides: "Dual-code lookup and CSRF cookie rename"
      contains: "extractErrorCode"
    - path: "src/proxy.ts"
      provides: "CSRF cookie name alignment"
      contains: "csrf_token"
  key_links:
    - from: "src/lib/server/error-sanitizer.ts"
      to: "API proxy routes"
      via: "sanitizeError called in route handlers"
      pattern: "extractBackendError"
    - from: "src/lib/fetch-with-retry.ts"
      to: "src/proxy.ts"
      via: "CSRF cookie name must match between reader and writer"
      pattern: "csrf_token"
---

<objective>
Build dual-envelope error parsing infrastructure, align CSRF cookie naming, and create shared error extraction helpers.

Purpose: Backend now sends errors in two shapes (old flat `{ error: string }` and new nested `{ error: { code, message } }`). The sanitizer, fetchWithRetry, and CSRF cookie name must all be updated atomically so that API errors display correctly and CSRF validation works end-to-end.

Output: Updated error-sanitizer.ts with dual-parse, updated fetch-with-retry.ts with dual-code lookup and CSRF rename, updated proxy.ts with CSRF rename, new api-error.ts client helper.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-error-envelope-api-alignment/17-CONTEXT.md
@.planning/phases/17-error-envelope-api-alignment/17-RESEARCH.md
@src/lib/server/error-sanitizer.ts
@src/lib/fetch-with-retry.ts
@src/proxy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual-envelope parsing to error-sanitizer and create parseApiError helper</name>
  <files>src/lib/server/error-sanitizer.ts, src/lib/api-error.ts</files>
  <action>
**In src/lib/server/error-sanitizer.ts:**

1. Add TypeScript interfaces for both envelope shapes above the existing `BackendError` interface:

```typescript
// New envelope shape from backend (Stripe-inspired)
// TODO(v1.3): Remove old envelope support after backend fully migrates
interface NewBackendErrorEnvelope {
  error: {
    code: string;
    message: string;
    requestId: string;
    details?: unknown;
  };
}

// Old envelope shape (flat) — existing BackendError interface covers this
```

2. Add a type guard function `isNewEnvelope(body: unknown): body is NewBackendErrorEnvelope` that checks:
   - `typeof body === 'object' && body !== null`
   - `'error' in body`
   - `typeof (body as Record<string, unknown>).error === 'object'`
   - `(body as Record<string, unknown>).error !== null`

3. Add `extractBackendError(body: unknown): { code?: string; message?: string }` that:
   - If `isNewEnvelope(body)`: returns `{ code: body.error.code, message: body.error.message }`
   - Otherwise: casts to old shape, returns `{ code: old.code, message: old.message || (typeof old.error === 'string' ? old.error : undefined) }`
   - Add `// TODO(v1.3): Remove old envelope support` comment

4. Update `sanitizeError()` function to use `extractBackendError()`:
   - Replace `const parsed: BackendError = ...` with calling `extractBackendError(backendResponse)` to get `{ code, message }`
   - Use extracted `code` for FRIENDLY_MESSAGES lookup (already works)
   - Use extracted `message` for `isMessageSafe()` check instead of `parsed.message || parsed.error || ''`
   - Keep the rest of the function (contextual messages, return shape) unchanged

**Create src/lib/api-error.ts (new file):**

Create a client-side helper for extracting error messages from proxy API responses. The proxy always outputs `{ error: string, code?: string }` — the `.error` field contains the message, NOT `.message`.

```typescript
/**
 * Extracts a human-readable error message from a dashboard API response body.
 * Dashboard API routes always output { error: string, code?: string } via sanitizeError().
 *
 * @param body - Parsed JSON response body
 * @param fallback - Fallback message if body is unparseable
 * @returns Human-readable error string with HTML tags stripped
 */
export function parseApiError(body: unknown, fallback: string): string {
  if (body === null || typeof body !== 'object') return fallback;
  const b = body as Record<string, unknown>;
  const message = typeof b.error === 'string' ? b.error : fallback;
  // Strip HTML tags per user decision (lightweight regex, no DOMParser)
  return message.replace(/<[^>]*>/g, '').trim() || fallback;
}
```

This helper:
- Reads `.error` (not `.message`) from the proxy's `SanitizedError` shape
- Strips HTML tags per locked user decision
- Returns fallback if body is unparseable
- Is safe for client-side use (no DOMParser dependency)
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root — no type errors in error-sanitizer.ts or api-error.ts. Confirm `isNewEnvelope`, `extractBackendError` exist in error-sanitizer.ts. Confirm `parseApiError` is exported from api-error.ts.
  </verify>
  <done>
error-sanitizer.ts correctly extracts error code and message from both `{ error: string, code? }` (old) and `{ error: { code, message } }` (new) backend shapes. A new parseApiError helper exists at src/lib/api-error.ts for client hooks to use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add dual-code lookup in fetchWithRetry and rename CSRF cookie everywhere</name>
  <files>src/lib/fetch-with-retry.ts, src/proxy.ts</files>
  <action>
**In src/lib/fetch-with-retry.ts:**

1. Add an `extractErrorCode` helper function near the top (after the existing helper functions, before `fetchWithRetry`):

```typescript
/**
 * Extract error code from either backend envelope shape.
 * New shape: { error: { code } }, Old shape: { code }
 * TODO(v1.3): Remove old envelope support (body?.code path)
 */
function extractErrorCode(body: unknown): string | undefined {
  if (body === null || typeof body !== 'object') return undefined;
  const b = body as Record<string, unknown>;
  // New shape: { error: { code } }
  if (typeof b.error === 'object' && b.error !== null) {
    return (b.error as Record<string, unknown>).code as string | undefined;
  }
  // Old shape: { code }
  return b.code as string | undefined;
}
```

2. Replace ALL `body?.code === 'EBADCSRFTOKEN'` checks with `extractErrorCode(body) === 'EBADCSRFTOKEN'`:
   - Line ~256: first CSRF check (in the `response.status === 403 && !didRetryAfterCsrf` block)
   - Line ~277: second CSRF check (in the `response.status === 403 && didRetryAfterCsrf` block)

3. Replace `body?.code === 'unverified_email'` with `extractErrorCode(body) === 'unverified_email'`:
   - Line ~293: in the `response.status === 403` unverified_email block

4. CSRF cookie rename — update `getCsrfToken()`:
   - Change `.find(row => row.startsWith('_csrf_token='))` to `.find(row => row.startsWith('csrf_token='))`
   - This is a hard switch per user decision — no fallback to old name

**In src/proxy.ts:**

5. CSRF cookie rename — 3 changes (hard switch, no fallback per user decision):
   - `setCsrfCookie()` function (~line 105): Change `'_csrf_token'` to `'csrf_token'` in `response.cookies.set()`
   - CSRF validation block (~line 131): Change `request.cookies.get('_csrf_token')` to `request.cookies.get('csrf_token')`
   - `refreshTokensFromMiddleware()` (~line 70): Change `request.cookies.get('_csrf_token')` to `request.cookies.get('csrf_token')`
   - Note: Line 73 already uses `csrf_token` in the cookieParts push — no change needed there

6. Verify the proxy still outputs old-shape `{ error: 'Invalid CSRF token', code: 'EBADCSRFTOKEN' }` on CSRF failure (line ~136) — this is correct, do NOT change this to new envelope shape. The proxy is the consumer of new shapes from backend, but it always outputs old shape to the client.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Grep for `_csrf_token` across the entire `src/` directory — should return ZERO results (all renamed to `csrf_token`). Grep for `body?.code ===` in fetch-with-retry.ts — should return ZERO results (all replaced with extractErrorCode).
  </verify>
  <done>
fetchWithRetry detects EBADCSRFTOKEN and unverified_email codes from both old and new envelope shapes. CSRF cookie name is `csrf_token` everywhere — proxy.ts sets it, proxy.ts validates it, fetch-with-retry.ts reads it. Zero references to `_csrf_token` remain in src/.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `grep -r '_csrf_token' src/` returns nothing (all renamed)
3. `grep -r 'body?.code ===' src/lib/fetch-with-retry.ts` returns nothing (all use extractErrorCode)
4. `grep -r 'isNewEnvelope' src/lib/server/error-sanitizer.ts` returns the type guard
5. `grep -r 'parseApiError' src/lib/api-error.ts` returns the exported function
</verification>

<success_criteria>
- error-sanitizer.ts handles both old and new backend envelope shapes, extracting code and message correctly from either
- fetchWithRetry detects special error codes (EBADCSRFTOKEN, unverified_email) from both envelope shapes
- CSRF cookie name is `csrf_token` everywhere in src/ — zero references to `_csrf_token` remain
- parseApiError helper exists at src/lib/api-error.ts reading the correct `.error` field from proxy responses
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-error-envelope-api-alignment/17-01-SUMMARY.md`
</output>
