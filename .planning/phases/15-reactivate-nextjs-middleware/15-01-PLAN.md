---
phase: 15-reactivate-nextjs-middleware
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/middleware.ts
  - src/lib/server/security-headers.ts
  - src/app/api/csp-report/route.ts
  - src/app/page.tsx
autonomous: true
requirements:
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "src/middleware.ts exists with export async function middleware (proxy.ts deleted)"
    - "_csrf_token cookie is set on page responses (double-submit cookie active)"
    - "Content-Security-Policy header present on all page responses with nonce"
    - "CSP includes font-src fonts.gstatic.com, connect-src wss:, and report-uri /api/csp-report"
    - "HSTS header set in production only"
    - "X-Request-ID header present on all responses"
    - "Cache-Control: no-store set on authenticated page responses"
    - "Unauthenticated requests to protected routes redirect to /?returnTo=/original/path"
    - "Landing page reads returnTo param and passes to login flow via sessionStorage"
    - "CSP report API route accepts POST, rate-limits by IP, forwards to CSP_REPORT_URI"
  artifacts:
    - path: "src/middleware.ts"
      provides: "Next.js middleware with CSRF, CSP, auth redirect, token refresh"
      contains: "export async function middleware"
    - path: "src/lib/server/security-headers.ts"
      provides: "Enhanced CSP header builder and security headers"
      contains: "fonts.gstatic.com"
    - path: "src/app/api/csp-report/route.ts"
      provides: "CSP violation report proxy with rate limiting"
      exports: ["POST"]
    - path: "src/app/page.tsx"
      provides: "Landing page with returnTo param handling"
      contains: "returnTo"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/server/security-headers.ts"
      via: "import buildCspHeader, getSecurityHeaders"
      pattern: "import.*security-headers"
    - from: "src/middleware.ts"
      to: "browser"
      via: "response.cookies.set _csrf_token"
      pattern: "_csrf_token"
    - from: "src/app/page.tsx"
      to: "src/app/(auth)/login/page.tsx"
      via: "redirect with returnTo → sessionStorage auth_callback_url"
      pattern: "returnTo|auth_callback_url"
    - from: "CSP header"
      to: "src/app/api/csp-report/route.ts"
      via: "report-uri /api/csp-report"
      pattern: "report-uri"
---

<objective>
Activate Next.js middleware by renaming proxy.ts to middleware.ts, enhance security headers (CSP directives, HSTS, Cache-Control, X-Request-ID), create CSP violation report endpoint, and update auth redirect to use returnTo parameter.

Purpose: This is the root cause fix for the v1.1 audit gaps -- middleware was inactive because the file was named proxy.ts with export function proxy. Renaming restores CSRF cookie issuance, CSP header injection, and auth redirects. Enhancements add the new requirements from Phase 15 context decisions.

Output: Working middleware.ts, enhanced security-headers.ts, CSP report route, updated landing page with returnTo handling.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-reactivate-nextjs-middleware/15-RESEARCH.md
@src/proxy.ts
@src/lib/server/security-headers.ts
@src/app/page.tsx
@src/app/(auth)/login/page.tsx
@src/app/auth/callback/page.tsx
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rename proxy.ts to middleware.ts with enhancements and create CSP report route</name>
  <files>
    src/middleware.ts
    src/proxy.ts (delete)
    src/lib/server/security-headers.ts
    src/app/api/csp-report/route.ts
  </files>
  <action>
**Step 1: Enhance security-headers.ts**

Update `src/lib/server/security-headers.ts`:

In `buildCspHeader()`:
- Change `font-src 'self'` to `font-src 'self' https://fonts.gstatic.com` (Google Fonts per locked decision)
- Change `connect-src 'self'` to `connect-src 'self' wss:` (WebSocket connections per locked decision, same policy all envs)
- Add `report-uri /api/csp-report` as a new directive at the end (CSP violation reporting per locked decision)

No changes to script-src, style-src, img-src, or other directives.

**Step 2: Create src/middleware.ts from proxy.ts**

Copy the entire contents of `src/proxy.ts` into a new `src/middleware.ts` with these modifications:

1. Rename the exported function: `export async function proxy` → `export async function middleware`
2. Add `const requestId = crypto.randomUUID();` at the start of the function (after the nonce line)
3. Add `requestHeaders.set('X-Request-ID', requestId);` after the existing `requestHeaders.set('Content-Security-Policy', ...)` line (always set, not conditional on !isApiRoute)
4. After the existing security headers block for non-API routes, add Cache-Control for authenticated pages:
   ```typescript
   if (!isApiRoute && hasSessionCookie) {
     response.headers.set('Cache-Control', 'no-store');
   }
   ```
   Note: `hasSessionCookie` is already defined in proxy.ts on line 202. Add this AFTER the security headers are applied (after the `if (!isApiRoute) { ... } else { ... }` block near the end).
5. Add X-Request-ID to response: `response.headers.set('X-Request-ID', requestId);` (before the return statement, apply to all responses including redirects)
6. Add HSTS for production only (after security headers, before return):
   ```typescript
   if (process.env.NODE_ENV === 'production') {
     response.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
   }
   ```
7. Update the auth redirect for unauthenticated dashboard routes (currently lines 216-229 in proxy.ts):
   - Change from redirecting to `/login` with `callbackUrl` to redirecting to `/?returnTo=`:
   ```typescript
   if (isDashboardRoute && !hasSessionCookie) {
     const landingUrl = new URL('/', request.url);
     if (pathname !== '/') {
       landingUrl.searchParams.set('returnTo', pathname);
     }
     const redirectResponse = NextResponse.redirect(landingUrl);
     // Apply security headers + X-Request-ID + HSTS to redirect
     const securityHeaders = getSecurityHeaders(nonce);
     for (const [key, value] of Object.entries(securityHeaders)) {
       redirectResponse.headers.set(key, value);
     }
     redirectResponse.headers.set('X-Request-ID', requestId);
     if (process.env.NODE_ENV === 'production') {
       redirectResponse.headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
     }
     return redirectResponse;
   }
   ```

8. Update the matcher config to add prefetch filtering (improves performance):
   ```typescript
   export const config = {
     matcher: [
       {
         source: '/((?!legal|_next/static|_next/image|favicon.ico|.*\\.png$).*)',
         missing: [
           { type: 'header', key: 'next-router-prefetch' },
           { type: 'header', key: 'purpose', value: 'prefetch' },
         ],
       },
     ],
   };
   ```

9. Also add X-Request-ID and HSTS to the early return for `/auth/*` routes and the login redirect for authenticated users hitting /login. Ensure ALL response paths get X-Request-ID and HSTS (production).

**Important:** Do NOT use `NextResponse.next()` without the request headers override for API routes when requestHeaders has been modified (X-Request-ID is always added). Update the conditional so `NextResponse.next({ request: { headers: requestHeaders } })` is always used.

**Step 3: Delete src/proxy.ts**

After creating middleware.ts, delete proxy.ts. Both files cannot coexist (Next.js throws a build error).

**Step 4: Create CSP report API route**

Create `src/app/api/csp-report/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';

// In-memory rate limiter: IP -> { count, resetAt }
const rateLimiter = new Map<string, { count: number; resetAt: number }>();
const RATE_LIMIT_MAX = 10;
const RATE_LIMIT_WINDOW_MS = 60_000;

function isRateLimited(ip: string): boolean {
  const now = Date.now();
  const entry = rateLimiter.get(ip);

  if (!entry || now > entry.resetAt) {
    rateLimiter.set(ip, { count: 1, resetAt: now + RATE_LIMIT_WINDOW_MS });
    return false;
  }

  if (entry.count >= RATE_LIMIT_MAX) {
    return true;
  }

  entry.count++;
  return false;
}

// Periodically clean stale entries to prevent memory leak
setInterval(() => {
  const now = Date.now();
  for (const [ip, entry] of rateLimiter) {
    if (now > entry.resetAt) {
      rateLimiter.delete(ip);
    }
  }
}, 5 * 60_000); // Clean every 5 minutes

export async function POST(request: NextRequest) {
  const ip = request.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ?? 'unknown';

  if (isRateLimited(ip)) {
    return new NextResponse(null, { status: 429 });
  }

  const reportUri = process.env.CSP_REPORT_URI;
  if (!reportUri) {
    // No webhook configured, silently accept
    return new NextResponse(null, { status: 204 });
  }

  try {
    const body = await request.json();
    await fetch(reportUri, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...body,
        timestamp: new Date().toISOString(),
        source_ip: ip,
      }),
    });
  } catch {
    // Silently ignore forwarding errors - don't break client
  }

  return new NextResponse(null, { status: 204 });
}
```

Note: The CSP report route must NOT require CSRF validation. The middleware already exempts `/api/auth/*` routes from CSRF. The CSP report route is at `/api/csp-report/` which is NOT under `/api/auth/`, so it WILL be subject to CSRF validation. However, browser-sent CSP violation reports cannot include custom headers (the browser sends them automatically). Therefore, add `/api/csp-report` as a CSRF exemption in middleware.ts:

In the CSRF validation block, change:
```typescript
if (isApiRoute && !isAuthRoute && isMutationMethod) {
```
to:
```typescript
const isCspReportRoute = pathname === '/api/csp-report';
if (isApiRoute && !isAuthRoute && !isCspReportRoute && isMutationMethod) {
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Verify `src/middleware.ts` exists and `src/proxy.ts` does not exist
3. Run `npm run build` - build succeeds, no errors about both middleware.ts and proxy.ts existing
4. Check `.next/server/middleware-manifest.json` after build - should NOT be empty, should contain middleware entry
5. Verify `src/lib/server/security-headers.ts` contains `fonts.gstatic.com`, `wss:`, and `report-uri /api/csp-report`
6. Verify `src/app/api/csp-report/route.ts` exists with POST handler
  </verify>
  <done>
- src/middleware.ts exists with `export async function middleware`, proxy.ts deleted
- CSP header includes font-src fonts.gstatic.com, connect-src wss:, report-uri /api/csp-report
- HSTS header guarded by production-only check
- X-Request-ID generated per request and set on both request and response headers
- Cache-Control: no-store applied to authenticated page responses
- Auth redirect goes to /?returnTo=/path for unauthenticated protected route access
- CSP report endpoint at /api/csp-report with rate limiting and webhook forwarding
- CSP report route is CSRF-exempt (browsers send reports without custom headers)
- Middleware manifest is populated after build
  </done>
</task>

<task type="auto">
  <name>Task 2: Update landing page to handle returnTo parameter</name>
  <files>
    src/app/page.tsx
  </files>
  <action>
The current landing page (`src/app/page.tsx`) simply redirects to `/guilds`:
```typescript
import { redirect } from 'next/navigation'
export default function Home() {
  redirect('/guilds')
}
```

This must be updated to handle the `returnTo` query parameter. When unauthenticated users hit a protected route, middleware redirects them to `/?returnTo=/original/path`. The landing page needs to:

1. If the user has an auth cookie (authenticated), redirect to `/guilds` (current behavior)
2. If the user does NOT have an auth cookie AND has a `returnTo` param, redirect to `/login?callbackUrl={returnTo}` so the existing login page logic picks up the callbackUrl and stores it in sessionStorage
3. If the user does NOT have an auth cookie AND has NO `returnTo` param, redirect to `/login`

This is a server component, so it can read cookies and searchParams.

Update `src/app/page.tsx`:

```typescript
import { redirect } from 'next/navigation';
import { cookies } from 'next/headers';

export default async function Home({
  searchParams,
}: {
  searchParams: Promise<{ returnTo?: string }>;
}) {
  const cookieStore = await cookies();
  const hasAuth = cookieStore.has('auth_token') || cookieStore.has('refresh_token');

  if (hasAuth) {
    redirect('/guilds');
  }

  // Unauthenticated: redirect to login, preserving returnTo as callbackUrl
  const params = await searchParams;
  const returnTo = params.returnTo;

  if (returnTo) {
    redirect(`/login?callbackUrl=${encodeURIComponent(returnTo)}`);
  }

  redirect('/login');
}
```

This approach:
- Keeps the landing page as a simple router between authenticated/unauthenticated states
- Bridges the middleware's `returnTo` param to the login page's existing `callbackUrl` param
- No changes needed to the login page or callback page -- they already handle `callbackUrl` → sessionStorage → post-login redirect
- The chain is: middleware (/?returnTo=/path) → landing page (/login?callbackUrl=/path) → login page (sessionStorage.auth_callback_url) → callback page (redirect to stored URL)
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Verify the full auth redirect chain: middleware sets returnTo → landing page reads it → passes to login as callbackUrl → login stores in sessionStorage → callback reads from sessionStorage after OAuth
  </verify>
  <done>
- Landing page reads returnTo from searchParams
- Authenticated users redirect to /guilds (unchanged behavior)
- Unauthenticated users with returnTo redirect to /login?callbackUrl={returnTo}
- Unauthenticated users without returnTo redirect to /login
- Complete auth redirect chain preserved: middleware → landing → login → OAuth → callback → original page
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds and `.next/server/middleware-manifest.json` is populated (not empty)
3. `src/middleware.ts` exists with `export async function middleware`, `src/proxy.ts` does not exist
4. `src/lib/server/security-headers.ts` buildCspHeader includes: `fonts.gstatic.com`, `wss:`, `report-uri /api/csp-report`
5. `src/app/api/csp-report/route.ts` exists with rate-limited POST handler
6. `src/app/page.tsx` handles returnTo searchParam for unauthenticated redirect chain
</verification>

<success_criteria>
- Middleware is active: CSRF cookie `_csrf_token` set on responses, CSP header present on page responses
- All security headers present: CSP, HSTS (prod), X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy
- X-Request-ID generated per request on all responses
- Cache-Control: no-store on authenticated page responses
- Auth redirect chain works: unauthenticated → /?returnTo=/path → /login?callbackUrl=/path → OAuth → callback → original path
- CSP report endpoint accepts violations and forwards to webhook with rate limiting
- Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-reactivate-nextjs-middleware/15-01-SUMMARY.md`
</output>
