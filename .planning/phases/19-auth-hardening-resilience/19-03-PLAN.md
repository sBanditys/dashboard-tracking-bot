---
phase: 19-auth-hardening-resilience
plan: 03
type: execute
wave: 1
depends_on: ["19-02"]
files_modified:
  - src/lib/fetch-with-retry.ts
  - src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx
autonomous: true
gap_closure: true
requirements: [AUTH-02, AUTH-03, AUTH-04]

must_haves:
  truths:
    - "A mutation that receives 503 is retried up to 5 times (not 3) with exponential backoff"
    - "A connection issues banner appears inline when a polling query gets 503 after previously succeeding"
  artifacts:
    - path: "src/lib/fetch-with-retry.ts"
      provides: "Mutation 503 retry loop runs independently of DEFAULT_MAX_RETRIES"
      contains: "MUTATION_MAX_RETRIES"
    - path: "src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx"
      provides: "ConnectionIssuesBanner renders within normal return path, not behind early return"
  key_links:
    - from: "src/lib/fetch-with-retry.ts"
      to: "mutation 503 retry block"
      via: "dedicated mutation retry counter independent of outer loop maxRetries"
      pattern: "mutationAttempt.*MUTATION_MAX_RETRIES"
    - from: "src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx"
      to: "src/components/connection-issues-banner.tsx"
      via: "conditional render within normal return, not behind early return"
      pattern: "ConnectionIssuesBanner"
---

<objective>
Close two verification gaps from Phase 19 execution:

1. **Mutation retry count (partial):** The outer `for` loop in `fetchWithRetry` is bounded by `DEFAULT_MAX_RETRIES=3`, which caps mutation 503 retries at 3 instead of the specified 5. Fix by using a dedicated mutation retry counter inside the mutation 503 block, independent of the outer loop's `attempt` variable.

2. **ConnectionIssuesBanner unreachable (blocker):** The accounts page has an early return at line 236 (`if (isError) { return <error UI> }`) that exits before the `ConnectionIssuesBanner` at line 273 can render. Fix by restructuring the error handling so the full-page error state only shows when `isError && !data` (initial load failure), and the banner shows inline when `isError && data` (polling failure after prior success).

Purpose: Achieve 6/6 must-have truths for Phase 19 verification.
Output: Two corrected source files passing re-verification.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-auth-hardening-resilience/19-02-SUMMARY.md
@.planning/phases/19-auth-hardening-resilience/19-VERIFICATION.md
@src/lib/fetch-with-retry.ts
@src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx
@src/components/connection-issues-banner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix mutation 503 retry to use dedicated counter reaching 5 retries</name>
  <files>src/lib/fetch-with-retry.ts</files>
  <action>
In `src/lib/fetch-with-retry.ts`, the mutation 503 retry block at lines 398-405 uses the outer loop's `attempt` variable and checks `attempt < MUTATION_MAX_RETRIES`. But the outer for-loop runs `attempt = 0..maxRetries` where `maxRetries = DEFAULT_MAX_RETRIES = 3`. The loop exits at `attempt = 4` (exceeds `maxRetries = 3`) before `MUTATION_MAX_RETRIES = 5` is reached.

Fix by converting the mutation 503 retry into a self-contained inner loop with its own counter, so the mutation gets exactly 5 retry attempts regardless of the outer loop bound.

Replace the existing mutation 503 retry block (lines 398-405):

```typescript
// Mutation 503 retry with onRetry callback
if (!canRetryRequest && response.status === 503 && attempt < MUTATION_MAX_RETRIES) {
  const delay = calculateBackoff(attempt);
  onRetry?.(attempt + 1, MUTATION_MAX_RETRIES);
  console.warn(`Mutation 503 — retrying (attempt ${attempt + 1}/${MUTATION_MAX_RETRIES})...`);
  await sleep(delay);
  continue;
}
```

With a self-contained inner retry loop that breaks out of the outer loop entirely:

```typescript
// Mutation 503 retry with dedicated counter (independent of outer loop maxRetries)
if (!canRetryRequest && response.status === 503) {
  for (let mutationAttempt = 1; mutationAttempt <= MUTATION_MAX_RETRIES; mutationAttempt++) {
    const delay = calculateBackoff(mutationAttempt - 1);
    onRetry?.(mutationAttempt, MUTATION_MAX_RETRIES);
    console.warn(`Mutation 503 — retrying (attempt ${mutationAttempt}/${MUTATION_MAX_RETRIES})...`);
    await sleep(delay);

    try {
      // Re-inject CSRF token for retry
      let retryOptions = options;
      if (CSRF_METHODS.has(requestMethod) && !isAuthEndpoint(url)) {
        const csrfToken = getCsrfToken();
        if (csrfToken) {
          const headers = new Headers(options?.headers);
          headers.set('X-CSRF-Token', csrfToken);
          retryOptions = { ...options, headers };
        }
      }

      const retryResponse = await fetch(url, retryOptions);
      if (retryResponse.status !== 503) {
        return retryResponse;
      }
    } catch (retryError) {
      // Network error during retry — continue trying
      if (mutationAttempt >= MUTATION_MAX_RETRIES) {
        throw retryError instanceof Error ? retryError : new Error(String(retryError));
      }
    }
  }
  // All 5 retries exhausted — return the original 503 response
  return response;
}
```

Key constraints:
- The inner loop uses `mutationAttempt` as its counter (1-indexed for display, running 1..5)
- `calculateBackoff(mutationAttempt - 1)` preserves 0-indexed backoff calculation
- `onRetry` fires before each retry sleep, exactly as before
- Each retry re-injects CSRF token (same pattern as line 273-280 in the outer loop)
- If a retry returns non-503, that response is returned immediately (success or other error)
- If a retry throws (network error), the loop continues unless retries exhausted
- After all 5 retries fail with 503, the original 503 response is returned (caller handles final failure)
- The outer loop's `continue` is NOT used — the inner loop fully handles the retry sequence and returns
  </action>
  <verify>
1. `npx tsc --noEmit` passes without errors
2. Grep confirms no remaining `attempt < MUTATION_MAX_RETRIES` pattern (old code removed)
3. Grep confirms `mutationAttempt <= MUTATION_MAX_RETRIES` exists (new inner loop)
4. Count the inner loop: `for (let mutationAttempt = 1; mutationAttempt <= MUTATION_MAX_RETRIES; ...)` with `MUTATION_MAX_RETRIES=5` runs 5 iterations — confirming 5 retry attempts
  </verify>
  <done>Mutation 503 retry runs a dedicated inner loop of exactly 5 retry attempts, independent of the outer loop's DEFAULT_MAX_RETRIES=3 bound</done>
</task>

<task type="auto">
  <name>Task 2: Make ConnectionIssuesBanner reachable by restructuring error early return</name>
  <files>src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx</files>
  <action>
In `src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx`, the early return at line 236 (`if (isError) { return <full-page error UI> }`) prevents `ConnectionIssuesBanner` at line 273 from ever rendering when `isError=true`.

The fix: change the early return to only fire when `isError && !data` (initial load failure, no cached data). When `isError && !!data` (polling failure after previous success), skip the early return so the normal render path runs and `ConnectionIssuesBanner` renders inline.

Replace the existing early return block (lines 236-250):

```tsx
if (isError) {
    return (
        <div className="flex flex-col items-center justify-center py-12 gap-4">
            <p className="text-sm text-red-400">Failed to load accounts</p>
            <button
                type="button"
                onClick={() => refetch()}
                className="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md bg-surface border border-border text-gray-300 hover:bg-surface-hover transition-colors"
            >
                <RefreshCw size={14} />
                Try again
            </button>
        </div>
    )
}
```

With a narrowed condition that only returns early when there is no cached data:

```tsx
if (isError && !data) {
    return (
        <div className="flex flex-col items-center justify-center py-12 gap-4">
            <p className="text-sm text-red-400">Failed to load accounts</p>
            <button
                type="button"
                onClick={() => refetch()}
                className="flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-md bg-surface border border-border text-gray-300 hover:bg-surface-hover transition-colors"
            >
                <RefreshCw size={14} />
                Try again
            </button>
        </div>
    )
}
```

This is a one-character change: `if (isError)` becomes `if (isError && !data)`.

With this change:
- When `isError=true` AND `data=undefined` (initial load failure): the early return fires, showing the full-page error UI. This is correct — the user has never seen data, so show an error page.
- When `isError=true` AND `data` exists (polling failure after prior success): execution continues to the normal return path, where `ConnectionIssuesBanner` at line 273 renders with `isError={isError} hasData={!!data}` (both true), showing the inline "Connection issues" banner. The stale cached data remains visible underneath.

No other changes needed — the `ConnectionIssuesBanner` component itself already has the `isError && hasData` gate and renders correctly when both props are true.
  </action>
  <verify>
1. `npx tsc --noEmit` passes without errors
2. Grep confirms `isError && !data` is the new condition (not bare `isError`)
3. Verify `ConnectionIssuesBanner` is rendered AFTER the early return block (line ~273), confirming it is now reachable when `isError=true && data` is truthy
  </verify>
  <done>ConnectionIssuesBanner renders inline when a polling query fails after previously succeeding (isError && data exists), while initial load failures still show the full-page error UI (isError && !data)</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes cleanly
2. Gap 1 closed: `MUTATION_MAX_RETRIES=5` is now the effective binding constraint for mutation 503 retries via the dedicated inner loop
3. Gap 2 closed: `ConnectionIssuesBanner` is structurally reachable in the normal render path when `isError && data` is truthy
4. No regressions: initial load error still shows full-page error UI; GET retry behavior unchanged; all existing tests pass
</verification>

<success_criteria>
- Mutation 503 retry inner loop runs exactly 5 iterations (verified by counting loop bounds)
- ConnectionIssuesBanner renders when isError=true and data exists (verified by code path analysis)
- TypeScript compiles without errors
- No behavioral regressions to existing retry, rate limit, or error handling
</success_criteria>

<output>
After completion, create `.planning/phases/19-auth-hardening-resilience/19-03-SUMMARY.md`
</output>
