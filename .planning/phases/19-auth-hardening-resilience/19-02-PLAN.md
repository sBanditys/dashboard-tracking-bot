---
phase: 19-auth-hardening-resilience
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/fetch-with-retry.ts
  - src/hooks/use-guilds.ts
  - src/hooks/use-tracking.ts
  - src/hooks/use-alerts.ts
  - src/hooks/use-email-alerts.ts
  - src/hooks/use-bulk-operations.ts
  - src/hooks/use-import.ts
  - src/hooks/use-exports.ts
  - src/components/rate-limit-banner.tsx
  - src/components/connection-issues-banner.tsx
  - src/components/forms/guild-settings-form.tsx
  - src/app/(dashboard)/layout.tsx
  - src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx
autonomous: true
requirements:
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "A mutation that receives 503 is retried up to 5 times with exponential backoff and a persistent 'Retrying...' toast"
    - "A blocking overlay appears on the form section while a mutation is retrying, preventing user edits"
    - "On successful retry after failures, the 'Retrying...' toast is dismissed and a 'Changes saved' success toast appears"
    - "Background polling hitting 429 does not block user-initiated mutations — separate rate limit buckets"
    - "A rate limit banner with countdown appears when polling hits 429, persists across page refresh via sessionStorage"
    - "A connection issues banner appears inline when a polling query gets 503 after previously succeeding"
  artifacts:
    - path: "src/lib/fetch-with-retry.ts"
      provides: "Mutation 503 retry with onRetry callback, split rate limit buckets, sessionStorage persistence"
      contains: "pollingRateLimitUntil"
    - path: "src/components/rate-limit-banner.tsx"
      provides: "Countdown banner for polling rate limit cooldown"
      contains: "Data updates paused"
    - path: "src/components/connection-issues-banner.tsx"
      provides: "Inline banner for 503 read errors"
      contains: "Connection issues"
    - path: "src/hooks/use-guilds.ts"
      provides: "isRetrying state from useUpdateGuildSettings mutation"
      contains: "isRetrying"
    - path: "src/components/forms/guild-settings-form.tsx"
      provides: "Blocking overlay during mutation retry"
      contains: "isRetrying"
  key_links:
    - from: "src/lib/fetch-with-retry.ts"
      to: "src/hooks/use-guilds.ts"
      via: "onRetry callback in fetchWithRetry config"
      pattern: "onRetry"
    - from: "src/hooks/use-guilds.ts"
      to: "src/components/forms/guild-settings-form.tsx"
      via: "isRetrying returned from hook"
      pattern: "isRetrying"
    - from: "src/lib/fetch-with-retry.ts"
      to: "src/components/rate-limit-banner.tsx"
      via: "sessionStorage polling_rate_limit_until"
      pattern: "polling_rate_limit_until"
    - from: "src/components/rate-limit-banner.tsx"
      to: "src/app/(dashboard)/layout.tsx"
      via: "import and render above children"
      pattern: "RateLimitBanner"
    - from: "src/components/connection-issues-banner.tsx"
      to: "src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx"
      via: "import and render with isError and hasData from useTracking query"
      pattern: "ConnectionIssuesBanner"
---

<objective>
Add mutation 503 retry with blocking UI, separate rate limit buckets for polling vs mutations, and user-facing banners for 503 read errors and 429 rate limits.

Purpose: Transient backend failures (503) no longer silently fail mutations — they retry automatically with user feedback. Background polling rate limits (429) no longer block user-initiated saves. Users see clear indicators when reads are failing or rate-limited.

Output: Modified fetchWithRetry with mutation retry + split rate limits, mutation hooks returning isRetrying state, blocking overlay on forms, RateLimitBanner with countdown, ConnectionIssuesBanner for read 503s.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-auth-hardening-resilience/19-RESEARCH.md
@src/lib/fetch-with-retry.ts
@src/hooks/use-guilds.ts
@src/components/forms/guild-settings-form.tsx
@src/app/(dashboard)/layout.tsx
@src/components/offline-banner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mutation 503 retry with onRetry callback and split rate limit buckets in fetchWithRetry</name>
  <files>src/lib/fetch-with-retry.ts</files>
  <action>
Modify `src/lib/fetch-with-retry.ts` with three changes:

**Change 1: Split globalRateLimitUntil into two buckets**

Replace the single `let globalRateLimitUntil = 0;` (line 34) with:
```typescript
let pollingRateLimitUntil = 0;    // for GET/HEAD/OPTIONS
let mutationRateLimitUntil = 0;   // for POST/PUT/PATCH/DELETE
```

Update `getRateLimitRemainingMs()` to accept a parameter indicating whether the call is a read or mutation:
```typescript
function getRateLimitRemainingMs(isMutation: boolean): number {
  const until = isMutation ? mutationRateLimitUntil : pollingRateLimitUntil;
  return Math.max(0, until - Date.now());
}
```

Update `setRateLimitCooldown()` to accept the same parameter and write to the correct bucket. For polling cooldowns, also persist to `sessionStorage`:
```typescript
function setRateLimitCooldown(ms: number, isMutation: boolean): void {
  if (ms <= 0) return;
  const boundedMs = Math.min(ms, MAX_RATE_LIMIT_WINDOW_MS);
  const expiryTime = Date.now() + boundedMs;
  if (isMutation) {
    mutationRateLimitUntil = Math.max(mutationRateLimitUntil, expiryTime);
  } else {
    pollingRateLimitUntil = Math.max(pollingRateLimitUntil, expiryTime);
    try {
      sessionStorage.setItem('polling_rate_limit_until', String(pollingRateLimitUntil));
    } catch { /* SSR or private browsing — ignore */ }
  }
}
```

Update the early exit check (currently around line 222-226) to pass `isMutation` (derive from `!canRetryRequest` or compute `isMutation = !RETRYABLE_METHODS.has(requestMethod)`):
```typescript
const isMutation = !RETRYABLE_METHODS.has(requestMethod);
if (!skipGlobalCooldown && !isAuthEndpoint(url)) {
  const cooldownMs = getRateLimitRemainingMs(isMutation);
  if (cooldownMs > 0) {
    throw new RateLimitError(cooldownMs);
  }
}
```

Update all existing calls to `setRateLimitCooldown` to pass `isMutation` as the second argument. Search for every `setRateLimitCooldown(` call and add the parameter.

When handling 429 responses, parse the `Retry-After` header (seconds) from the response and use it to set the cooldown duration: `setRateLimitCooldown(retryAfterSeconds * 1000, isMutation)`. Fall back to `MAX_RATE_LIMIT_WINDOW_MS` if the `Retry-After` header is absent or cannot be parsed:
```typescript
const retryAfterHeader = response.headers.get('Retry-After');
const retryAfterSeconds = retryAfterHeader ? parseInt(retryAfterHeader, 10) : NaN;
const cooldownMs = !isNaN(retryAfterSeconds) && retryAfterSeconds > 0
  ? retryAfterSeconds * 1000
  : MAX_RATE_LIMIT_WINDOW_MS;
setRateLimitCooldown(cooldownMs, isMutation);
```
This applies to every code path that currently calls `setRateLimitCooldown` in response to a 429 status.

On module load, restore `pollingRateLimitUntil` from `sessionStorage`:
```typescript
try {
  const stored = sessionStorage.getItem('polling_rate_limit_until');
  if (stored) {
    const expiry = parseInt(stored, 10);
    if (expiry > Date.now()) {
      pollingRateLimitUntil = expiry;
    } else {
      sessionStorage.removeItem('polling_rate_limit_until');
    }
  }
} catch { /* SSR or private browsing */ }
```

**Change 2: Add onRetry callback to config type**

Extend the config type (the third parameter to `fetchWithRetry`):
```typescript
config?: number | {
  maxRetries?: number;
  skipGlobalCooldown?: boolean;
  onRetry?: (attempt: number, maxAttempts: number) => void;
  onRetrySettled?: () => void;
}
```

Parse `onRetry` and `onRetrySettled` from the config object alongside existing fields.

**Change 3: Add mutation 503 retry block**

After the existing `canRetryRequest && RETRYABLE_SERVER_STATUSES.has(response.status)` block (which handles GET/HEAD/OPTIONS 503 retries), add a NEW block for mutation 503 retries:

```typescript
const MUTATION_MAX_RETRIES = 5;

// Mutation 503 retry with onRetry callback
if (!canRetryRequest && response.status === 503 && attempt < MUTATION_MAX_RETRIES) {
  const delay = calculateBackoff(attempt);
  onRetry?.(attempt + 1, MUTATION_MAX_RETRIES);
  console.warn(`Mutation 503 — retrying (attempt ${attempt + 1}/${MUTATION_MAX_RETRIES})...`);
  await sleep(delay);
  continue;
}
```

Also call `onRetry` in the existing network error retry block (the catch block at the bottom of the for loop) so that network errors also trigger the overlay/toast for mutations:
```typescript
if (!canRetryRequest) {
  onRetry?.(attempt + 1, MUTATION_MAX_RETRIES);
}
```

After the retry loop completes (either successfully or exhausted), call `onRetrySettled?.()` in the finally block or after the loop. This tells the caller retries are done regardless of outcome.

**Important:** Do NOT change the existing behavior for GET/HEAD/OPTIONS retries — those already work correctly. The mutation retry block is additive.
  </action>
  <verify>
Run `npx tsc --noEmit` — should pass with no errors.

Confirm the split:
```bash
grep -n "pollingRateLimitUntil\|mutationRateLimitUntil" src/lib/fetch-with-retry.ts
```

Confirm `globalRateLimitUntil` is fully removed:
```bash
grep -c "globalRateLimitUntil" src/lib/fetch-with-retry.ts
# Expected: 0
```

Confirm mutation 503 retry block exists:
```bash
grep -n "MUTATION_MAX_RETRIES\|Mutation 503" src/lib/fetch-with-retry.ts
```

Confirm onRetry is in config type:
```bash
grep -n "onRetry" src/lib/fetch-with-retry.ts
```
  </verify>
  <done>
fetchWithRetry retries mutation 503s up to 5 times with exponential backoff and fires onRetry callback, rate limit cooldowns are split between polling and mutations with sessionStorage persistence for polling, Retry-After header is parsed on 429 responses to set cooldown duration, and TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add isRetrying to mutation hooks, create blocking overlay, rate limit banner, and connection issues banner</name>
  <files>
    src/hooks/use-guilds.ts
    src/hooks/use-tracking.ts
    src/hooks/use-alerts.ts
    src/hooks/use-email-alerts.ts
    src/hooks/use-bulk-operations.ts
    src/hooks/use-import.ts
    src/hooks/use-exports.ts
    src/components/rate-limit-banner.tsx
    src/components/connection-issues-banner.tsx
    src/components/forms/guild-settings-form.tsx
    src/app/(dashboard)/layout.tsx
  </files>
  <action>
**Part A: Add isRetrying state and onRetry to all mutation hooks**

For each mutation hook across all 7 hook files, add:
1. A `useState<boolean>(false)` for `isRetrying` inside the hook function.
2. Pass `onRetry` callback in the `fetchWithRetry` config that:
   - Sets `isRetrying` to `true` on first call.
   - On first retry (attempt === 1), calls `toast.loading('Retrying...', { id: 'mutation-retry', duration: Infinity })`.
3. Pass `onRetrySettled` callback that sets `isRetrying` to `false`.
4. In `onSuccess`: call `toast.dismiss('mutation-retry')` then `toast.success('Changes saved')` (only if retries occurred — check with a ref `didRetryRef`).
5. In `onError`: call `toast.dismiss('mutation-retry')` (only if retries occurred), then show the existing error toast. If retries were exhausted, show `toast.error('Failed to save changes. Please try again later.')`.
6. Return `isRetrying` alongside the existing mutation return value: `return { ...mutation, isRetrying }`.

**Hooks to modify (each has 1+ mutation functions):**
- `use-guilds.ts`: `useUpdateGuildSettings` (primary target — this one has the form overlay)
- `use-tracking.ts`: `useDeleteAccount`, `useAddAccount`, `useAddBrand` (these use confirmation modals — `isRetrying` available but overlay less critical since modals already block)
- `use-alerts.ts`: `useCreateThreshold`, `useDeleteThreshold`, `useToggleThreshold`, `useUpdateAlertSettings`, `useBulkToggleThresholds`, `useBulkDeleteThresholds`
- `use-email-alerts.ts`: mutation hooks in this file
- `use-bulk-operations.ts`: `useBulkDelete`
- `use-import.ts`: `useConfirmImport`
- `use-exports.ts`: mutation hooks in this file

**Pattern for toast.loading ID:** Use `'mutation-retry'` as the toast ID. Since the blocking overlay prevents concurrent mutations on the same form, ID collision is acceptable. The toast persists across route navigation because Sonner Toaster is in the root layout.

**Important:** For the `didRetryRef` pattern, use a `useRef(false)` that is set to `true` inside `onRetry` and reset to `false` after the mutation settles. This prevents showing "Changes saved" on non-retry successes (the existing success toasts already handle the normal case).

**Part B: Add blocking overlay to GuildSettingsForm**

In `src/components/forms/guild-settings-form.tsx`:
1. Destructure `isRetrying` from the `useUpdateGuildSettings` hook call.
2. When `isRetrying` is true, render a semi-transparent overlay div over the form section:
```tsx
{isRetrying && (
  <div className="absolute inset-0 z-10 flex items-center justify-center rounded-lg bg-background/60 backdrop-blur-[1px]">
    <div className="flex items-center gap-2 text-sm text-muted-foreground">
      <Loader2 className="h-4 w-4 animate-spin" />
      <span>Saving changes...</span>
    </div>
  </div>
)}
```
3. Ensure the form's parent container has `position: relative` so the absolute overlay is scoped correctly. Add `relative` to the wrapping div's className if not already present.
4. Import `Loader2` from `lucide-react` (already a project dependency).

**Part C: Create RateLimitBanner component**

Create `src/components/rate-limit-banner.tsx` (new file):
- `'use client'` directive.
- On mount, read `sessionStorage.getItem('polling_rate_limit_until')`, parse as integer.
- If the stored expiry is in the future, show a banner. Otherwise return null.
- Use `setInterval` (1s tick) to update a countdown display: `"Data updates paused -- resuming in Xm"` where X is `Math.ceil(remainingMs / 60000)`. When X is less than 1 minute, show seconds: `"resuming in Xs"`.
- When countdown reaches 0, remove the sessionStorage key and hide the banner.
- Listen for a custom event `'rate-limit-updated'` (dispatched by fetchWithRetry when it writes to sessionStorage) to reactively show the banner even if it wasn't visible on mount.
- Visual style: follow `OfflineBanner` pattern — fixed top banner with `z-50`, amber/yellow color scheme (distinct from the OfflineBanner's red). Use `AlertTriangle` icon from lucide-react.

In `src/lib/fetch-with-retry.ts`, after writing to `sessionStorage` in `setRateLimitCooldown`, dispatch the custom event:
```typescript
try {
  window.dispatchEvent(new CustomEvent('rate-limit-updated'));
} catch { /* SSR */ }
```

**Part D: Create ConnectionIssuesBanner component**

Create `src/components/connection-issues-banner.tsx` (new file):
- `'use client'` directive.
- Props: `{ isError: boolean; hasData: boolean }` — `isError` comes from React Query's error state, `hasData` indicates the query has previously succeeded (prevents showing on initial load failures).
- Show the banner only when `isError && hasData` — this means the query was working and then started failing (polling 503), not that the initial load failed.
- Visual: subtle inline banner (not fixed/floating), uses `AlertCircle` icon, text: `"Connection issues -- retrying..."`. Auto-dismisses when parent stops passing `isError=true`.
- This component is rendered INLINE within sections that use polling, not in the layout. Individual pages/components that poll will import and render it.

**Part E: Add RateLimitBanner to dashboard layout**

In `src/app/(dashboard)/layout.tsx`:
1. Import `RateLimitBanner` from `@/components/rate-limit-banner`.
2. Render `<RateLimitBanner />` inside the `<main>` element, after `<Breadcrumbs />` and before `{children}`.

**Part F: Wire ConnectionIssuesBanner into accounts page**

In `src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx`:
1. Import `ConnectionIssuesBanner` from `@/components/connection-issues-banner`.
2. The page uses `useTracking` (or similar polling hook) to fetch tracking data. Destructure `isError` and `data` (or equivalent state) from the hook.
3. Render `<ConnectionIssuesBanner isError={isError} hasData={!!data} />` near the top of the page content area (before the accounts table/list, after any headers).
4. This serves as the reference integration — other polling-heavy pages (`brands/page.tsx`, `posts/page.tsx`, `alerts/page.tsx`) can follow the same pattern in future work, but this one page wiring is sufficient to prove the component works end-to-end.
  </action>
  <verify>
Run `npx tsc --noEmit` — should pass with no errors.

Confirm isRetrying is exported from useUpdateGuildSettings:
```bash
grep -n "isRetrying" src/hooks/use-guilds.ts
```

Confirm overlay is rendered in GuildSettingsForm:
```bash
grep -n "isRetrying\|Saving changes" src/components/forms/guild-settings-form.tsx
```

Confirm RateLimitBanner exists and is imported in layout:
```bash
grep -rn "RateLimitBanner" src/
```

Confirm ConnectionIssuesBanner exists and is wired into accounts page:
```bash
grep -rn "ConnectionIssuesBanner" src/components/connection-issues-banner.tsx src/app/\(dashboard\)/guilds/\[guildId\]/accounts/page.tsx
```

Confirm no references to `globalRateLimitUntil` remain anywhere in src/:
```bash
grep -rn "globalRateLimitUntil" src/
# Expected: 0 results
```
  </verify>
  <done>
All mutation hooks return isRetrying state, GuildSettingsForm shows a blocking overlay during retry, RateLimitBanner shows countdown when polling hits 429, ConnectionIssuesBanner is wired into accounts page for inline 503 read errors, and TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no type errors across entire project
2. `globalRateLimitUntil` is fully removed — `grep -rn "globalRateLimitUntil" src/` returns 0 results
3. `pollingRateLimitUntil` and `mutationRateLimitUntil` exist in fetch-with-retry.ts
4. Mutation 503 retry block exists with MUTATION_MAX_RETRIES = 5
5. `onRetry` callback is in the fetchWithRetry config type
6. `isRetrying` is returned from all mutation hooks
7. GuildSettingsForm renders blocking overlay when isRetrying is true
8. RateLimitBanner component exists and is rendered in dashboard layout
9. ConnectionIssuesBanner component exists and is rendered in accounts page with isError and hasData props
10. sessionStorage persistence for polling rate limit works (write on 429, read on mount)
11. Retry-After header is parsed on 429 responses and used to set cooldown duration (falling back to MAX_RATE_LIMIT_WINDOW_MS if absent)
</verification>

<success_criteria>
- A mutation that receives 503 retries up to 5 times with exponential backoff
- A persistent "Retrying..." toast appears during mutation retry and survives navigation
- A blocking overlay with spinner covers the form section during retry
- On successful retry, "Changes saved" toast appears
- On final failure after 5 attempts, a failure toast appears
- Background polling 429 sets only pollingRateLimitUntil, not mutationRateLimitUntil
- User-initiated mutation 429 sets only mutationRateLimitUntil, not pollingRateLimitUntil
- RateLimitBanner shows countdown from sessionStorage and auto-dismisses when expired
- ConnectionIssuesBanner shows inline when a polling query errors after previously succeeding
- TypeScript compiles cleanly with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-auth-hardening-resilience/19-02-SUMMARY.md`
</output>
