---
phase: 14-fix-import-confirm-csrf-bypass
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-import.ts
autonomous: true
requirements:
  - AUTH-03
  - IMPEX-04

must_haves:
  truths:
    - "useConfirmImport calls fetchWithRetry instead of raw fetch() for the POST request"
    - "POST to /api/guilds/[guildId]/accounts/import/confirm includes X-CSRF-Token header automatically"
    - "Import confirm flow completes without 403 EBADCSRFTOKEN error"
    - "SSE streaming progress (response.body.getReader) works identically after the change"
  artifacts:
    - path: "src/hooks/use-import.ts"
      provides: "CSRF-protected import confirm mutation"
      contains: "fetchWithRetry"
  key_links:
    - from: "src/hooks/use-import.ts"
      to: "src/lib/fetch-with-retry.ts"
      via: "fetchWithRetry() call in useConfirmImport"
      pattern: "fetchWithRetry\\(\\s*`/api/guilds/"
    - from: "src/lib/fetch-with-retry.ts"
      to: "src/proxy.ts"
      via: "X-CSRF-Token header injection matching _csrf_token cookie"
      pattern: "headers\\.set\\('X-CSRF-Token'"
---

<objective>
Replace raw `fetch()` with `fetchWithRetry()` in useConfirmImport to close the CSRF bypass gap.

Purpose: The import confirm POST endpoint is the only mutation in the codebase that bypasses CSRF token injection because it uses raw `fetch()` instead of the project-standard `fetchWithRetry` wrapper. This creates a security gap where the request lacks the `X-CSRF-Token` header, causing 403 EBADCSRFTOKEN errors in production (or silently bypassing CSRF if the proxy validation was disabled).

Output: Single file modified — `src/hooks/use-import.ts` with `fetch(` replaced by `fetchWithRetry(` on line 95.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-fix-import-confirm-csrf-bypass/14-RESEARCH.md
@src/hooks/use-import.ts
@src/lib/fetch-with-retry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace raw fetch() with fetchWithRetry() in useConfirmImport</name>
  <files>src/hooks/use-import.ts</files>
  <action>
In `src/hooks/use-import.ts`, change line 95 from `const response = await fetch(` to `const response = await fetchWithRetry(`.

Specifically, replace:
```typescript
const response = await fetch(
    `/api/guilds/${guildId}/accounts/import/confirm`,
    {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ importId }),
        credentials: 'include',
    }
)
```

With:
```typescript
const response = await fetchWithRetry(
    `/api/guilds/${guildId}/accounts/import/confirm`,
    {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ importId }),
        credentials: 'include',
    }
)
```

Key constraints:
- Do NOT change anything else in the file. The SSE streaming loop (lines 112-154), error handling, cache invalidation, and state management are all correct and must remain untouched.
- Do NOT remove `credentials: 'include'` — fetchWithRetry passes options through to fetch(), and auth cookies are needed for the proxy route to validate the session.
- Do NOT add or change imports — `fetchWithRetry` is already imported at line 6: `import { fetchWithRetry } from '@/lib/fetch-with-retry'`
- `fetchWithRetry` returns a standard `Response` object (same as `fetch`), so `response.body.getReader()` streaming works identically.

Why this works: `fetchWithRetry` (in `src/lib/fetch-with-retry.ts`) automatically reads the `_csrf_token` cookie via `getCsrfToken()` and sets the `X-CSRF-Token` header for all POST/PUT/PATCH/DELETE requests to non-auth endpoints (lines 219-229). It also provides silent CSRF retry on 403 EBADCSRFTOKEN (lines 251-268), 401 session refresh, and rate limit handling — all behaviors the import confirm flow was previously missing.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — must pass with no errors (confirms fetchWithRetry return type is compatible with the streaming logic).
2. Run `grep -n 'await fetch(' src/hooks/use-import.ts` — must return NO results (no raw fetch() calls remain in the file).
3. Run `grep -n 'await fetchWithRetry(' src/hooks/use-import.ts` — must show 3 results (lines for useImportTemplate, useImportPreview, and useConfirmImport).
4. Run `grep -c 'fetchWithRetry' src/hooks/use-import.ts` — must show at least 4 (1 import + 3 usages).
  </verify>
  <done>
The single `fetch(` call in `useConfirmImport` (line 95) is replaced with `fetchWithRetry(`. No other lines changed. TypeScript compiles without errors. All three mutation functions in use-import.ts now consistently use fetchWithRetry. The import confirm POST will include X-CSRF-Token header automatically, closing the AUTH-03 gap for this endpoint.
  </done>
</task>

</tasks>

<verification>
1. **CSRF header injection:** Grep confirms no raw `fetch()` calls remain in `src/hooks/use-import.ts` — all mutations use `fetchWithRetry`.
2. **TypeScript compilation:** `npx tsc --noEmit` passes — the `Response` type from `fetchWithRetry` is compatible with `response.body.getReader()` streaming.
3. **Code integrity:** The SSE streaming loop, error handling, buffer management, and cache invalidation in `useConfirmImport` remain unchanged — only the fetch wrapper changed.
4. **Pattern consistency:** All three hook functions (`useImportTemplate`, `useImportPreview`, `useConfirmImport`) now use the same `fetchWithRetry` pattern.
</verification>

<success_criteria>
- `src/hooks/use-import.ts` uses `fetchWithRetry` for all three HTTP calls (template download, import preview, import confirm)
- No raw `fetch()` calls exist in the file
- TypeScript compiles without errors
- The import confirm POST request will include `X-CSRF-Token` header via `fetchWithRetry` CSRF injection
</success_criteria>

<output>
After completion, create `.planning/phases/14-fix-import-confirm-csrf-bypass/14-01-SUMMARY.md`
</output>
