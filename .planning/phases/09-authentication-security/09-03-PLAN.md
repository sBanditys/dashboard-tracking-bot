---
phase: 09-authentication-security
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/lib/fetch-with-retry.ts
  - src/app/auth/unverified-email/page.tsx
  - src/app/auth/callback/page.tsx
  - src/middleware.ts
  - src/hooks/use-user.ts
autonomous: true

must_haves:
  truths:
    - "On 401, client silently attempts refresh first, then retries original request before surfacing error"
    - "After final auth failure, toast notification appears and user is redirected to login with return URL saved"
    - "User with unverified Discord email sees a dedicated error page with step-by-step verification instructions"
    - "After re-login, user is redirected back to the page they were on (return URL preserved)"
    - "Session expiry feels graceful — toast notification then redirect after 2-3 seconds"
  artifacts:
    - path: "src/lib/fetch-with-retry.ts"
      provides: "Silent refresh, toast on failure, return URL preservation"
      contains: "returnUrl"
    - path: "src/app/auth/unverified-email/page.tsx"
      provides: "Dedicated unverified email error page with Discord verification instructions"
      contains: "verify your email"
    - path: "src/middleware.ts"
      provides: "Return URL in login redirect via callbackUrl parameter"
      contains: "callbackUrl"
  key_links:
    - from: "fetch-with-retry.ts"
      to: "/api/auth/refresh"
      via: "refreshSession on 401"
      pattern: "refreshSession"
    - from: "fetch-with-retry.ts"
      to: "sonner toast"
      via: "toast on final auth failure"
      pattern: "toast"
    - from: "middleware.ts"
      to: "/login?callbackUrl"
      via: "redirect with return URL"
      pattern: "callbackUrl"
    - from: "auth/callback/page.tsx"
      to: "/auth/unverified-email"
      via: "redirect on unverified_email error"
      pattern: "unverified.email"
---

<objective>
Implement the dashboard-side authentication UX improvements: graceful session expiry with toast + return URL, and a dedicated unverified email error page with Discord verification instructions.

Purpose: Users need seamless session continuation (AUTH-01) and clear rejection with helpful guidance when their email is unverified (AUTH-02). Auth failures should feel graceful, not jarring.
Output: Silent token refresh with toast on failure, return URL preservation across re-login, and a dedicated unverified email page.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-authentication-security/09-01-SUMMARY.md
@src/lib/fetch-with-retry.ts
@src/middleware.ts
@src/hooks/use-user.ts
@src/app/auth/callback/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance auth failure UX with toast, return URL, and unverified email handling</name>
  <files>
    src/lib/fetch-with-retry.ts
    src/middleware.ts
    src/hooks/use-user.ts
    src/app/auth/callback/page.tsx
  </files>
  <action>
    **Per user decisions:**
    - Silent background refresh — user never sees token expiry during normal use (already working via `refreshSession()` in fetchWithRetry)
    - On refresh failure: show "Session expired, please log in again" toast, then redirect to login after 2-3 seconds
    - Return URL preserved: after re-login, redirect back to the page user was on
    - On 401: silently attempt token refresh first, then retry the original request. Only surface error if refresh also fails (already working)
    - After final auth failure: toast notification + redirect to login with return URL saved

    In `src/lib/fetch-with-retry.ts`:
    1. Update `recoverExpiredSession()` to:
       - Import `toast` from `sonner` (already a project dependency, used in Phase 8).
       - Show toast: `toast.error('Session expired, please log in again')` BEFORE redirect.
       - Save current URL as return URL: `const returnUrl = window.location.pathname + window.location.search`.
       - Redirect to `/login?callbackUrl=${encodeURIComponent(returnUrl)}` instead of `/login?error=session_expired`.
       - Add a 2.5-second delay between toast and redirect so user sees the message: `await new Promise(r => setTimeout(r, 2500))`.
    2. Handle 403 with `code: 'unverified_email'` response:
       - After the 401 retry logic, add a check: if response status is 403, try to parse the body and check for `code === 'unverified_email'`.
       - If detected, redirect to `/auth/unverified-email` page.
       - This handles the middleware enforcement from Plan 01 (every request checks email_verified in JWT).
       - Important: only do this check for non-auth endpoints and only read body once (clone response if needed).

    In `src/middleware.ts`:
    3. The middleware already saves `callbackUrl` for protected route redirects (line 19). Verify this works correctly and the login page uses it after successful auth.
    4. Add `/auth/unverified-email` to the public routes that don't require auth (it's under `/auth` which currently may not be protected, but verify).

    In `src/hooks/use-user.ts`:
    5. No changes needed — useUser already handles auth errors. But verify that when user gets redirected to login, the query cache is cleared.

    In `src/app/auth/callback/page.tsx`:
    6. Handle `error=unverified_email` in the callback page: if `searchParams.get('error') === 'unverified_email'`, redirect to `/auth/unverified-email` instead of `/login?error=unverified_email`.
    7. After successful auth (token exchange), check for `callbackUrl` in the original login flow and redirect there instead of `/`.
       - The login page should pass `callbackUrl` through the OAuth flow. Check if the current login page reads `callbackUrl` from its URL params and stores it in sessionStorage for the callback to use.
       - If not, store `callbackUrl` in sessionStorage in the login page before redirecting to OAuth. In the callback page, read it from sessionStorage and redirect there after successful auth.
       - Pattern: `sessionStorage.getItem('auth_callback_url')` → redirect there → `sessionStorage.removeItem('auth_callback_url')`.
  </action>
  <verify>
    Run: `npx next build` to verify no build errors.
    Verify fetch-with-retry.ts shows toast and redirects with callbackUrl on auth failure.
    Verify callback page handles unverified_email error.
    Verify middleware doesn't block /auth/unverified-email route.
  </verify>
  <done>
    Auth failure shows toast "Session expired, please log in again" and redirects to login with return URL after 2.5 seconds. 403 unverified_email responses redirect to dedicated page. Callback page handles unverified_email error. Return URL preserved across re-login flow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dedicated unverified email error page</name>
  <files>
    src/app/auth/unverified-email/page.tsx
  </files>
  <action>
    Per user decisions:
    - Dedicated error page (not a banner on login page) when unverified email detected
    - Page includes step-by-step instructions: open Discord settings -> Account -> verify email
    - Helpful not punitive tone
    - Retry button vs login link — pick best CTA (Claude's discretion: use "Try again" button that redirects to login, plus a "Go to Discord Settings" external link)

    Create `src/app/auth/unverified-email/page.tsx`:
    1. This is a public page (no auth required — user is already rejected).
    2. Use the existing dark theme styling consistent with login page and auth callback page.
    3. Layout: centered card on dark background (matches auth callback pattern).
    4. Content:
       - Icon: shield or email icon (inline SVG, consistent with existing empty state icons).
       - Title: "Email Verification Required"
       - Subtitle: "Your Discord account needs a verified email address to use this dashboard."
       - Step-by-step instructions card:
         - Step 1: Open Discord and go to **User Settings** (gear icon near your username)
         - Step 2: Navigate to **My Account**
         - Step 3: Under **Email**, click **Verify** or add an email if none is set
         - Step 4: Check your email inbox and click the verification link from Discord
         - Step 5: Come back here and try again
       - Primary CTA button: "Try Again" → links to `/login` (attempts full re-auth)
       - Secondary link: "Need help? Visit Discord Support" → external link to Discord help article
    5. Style:
       - Card: `bg-surface border border-border rounded-xl p-8`
       - Steps: numbered list with `text-gray-300` body, `text-white` emphasized text
       - Primary button: `bg-accent-purple hover:bg-accent-purple/90 text-white` (consistent with existing buttons)
       - Secondary link: `text-gray-400 hover:text-gray-300 underline`
    6. This is a server component (no client-side state needed).
    7. Add metadata: `export const metadata = { title: 'Email Verification Required' }`.
  </action>
  <verify>
    Run: `npx next build` to verify page compiles.
    Visit `/auth/unverified-email` in development and verify the page renders correctly with all steps.
    Verify the page is accessible without authentication (middleware doesn't block it).
  </verify>
  <done>
    Dedicated unverified email page exists at `/auth/unverified-email` with step-by-step Discord email verification instructions, "Try Again" CTA button, and Discord Support link. Page is styled consistently with dashboard dark theme. Accessible without authentication.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npx next build`
2. Auth failure shows toast and redirects with return URL
3. Unverified email page renders at /auth/unverified-email
4. Callback page handles unverified_email error by redirecting to unverified email page
5. Return URL is preserved through re-login flow
6. Middleware allows access to /auth/unverified-email without auth
</verification>

<success_criteria>
- Session expiry triggers graceful toast notification + redirect to login with saved return URL
- After re-login, user returns to the page they were on
- Unverified email users see a dedicated, helpful page with step-by-step instructions
- Auth failure UX is invisible during normal use (silent refresh) and graceful when it fails
</success_criteria>

<output>
After completion, create `.planning/phases/09-authentication-security/09-03-SUMMARY.md`
</output>
