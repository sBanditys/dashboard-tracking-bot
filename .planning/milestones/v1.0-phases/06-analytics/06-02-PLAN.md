---
phase: 06-analytics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/analytics/counter-card.tsx
  - src/components/analytics/counter-card-skeleton.tsx
  - src/components/analytics/time-range-selector.tsx
autonomous: true

must_haves:
  truths:
    - "Counter card displays value, trend delta, and optional platform breakdown"
    - "Time range selector renders 7d/30d/90d toggle buttons"
    - "Counter card skeleton matches real card dimensions"
  artifacts:
    - path: "src/components/analytics/counter-card.tsx"
      provides: "CounterCard component with trend indicator"
      exports: ["CounterCard"]
    - path: "src/components/analytics/counter-card-skeleton.tsx"
      provides: "Loading skeleton for counter card"
      exports: ["CounterCardSkeleton"]
    - path: "src/components/analytics/time-range-selector.tsx"
      provides: "7d/30d/90d toggle"
      exports: ["TimeRangeSelector"]
  key_links:
    - from: "src/components/analytics/counter-card.tsx"
      to: "src/types/analytics.ts"
      via: "imports TimeRange type"
      pattern: "import.*analytics"
---

<objective>
Build the counter card and time range selector UI components for the analytics dashboard.

Purpose: Counter cards show key metrics (total accounts, posts, brands) with trend indicators. The time range selector controls which period all analytics sections display. These are the first visual elements users see.
Output: Reusable CounterCard, CounterCardSkeleton, and TimeRangeSelector components.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

Reference existing patterns:
@src/components/stat-card.tsx (existing stat card — reference styling, do NOT modify)
@src/components/ui/skeleton.tsx (Skeleton component for loading states)
@src/lib/utils.ts (cn utility)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CounterCard with trend indicator and platform breakdown</name>
  <files>src/components/analytics/counter-card.tsx, src/components/analytics/counter-card-skeleton.tsx</files>
  <action>
    1. Create `src/components/analytics/counter-card.tsx`:

    Props interface:
    ```typescript
    interface CounterCardProps {
      label: string
      value: number
      previousValue: number
      icon?: string
      breakdown?: Array<{ platform: string; count: number }>
      className?: string
    }
    ```

    Implementation:
    - Container: `bg-surface border border-border rounded-sm p-4` (matches existing StatCard styling)
    - Top row: label (text-sm text-gray-400) + icon
    - Value: text-3xl font-bold text-white, use `value.toLocaleString()` for formatting
    - Trend delta calculation:
      - If previousValue > 0: `delta = Math.round(((value - previousValue) / previousValue) * 100)`
      - Show as: `↑ 15% vs previous period` (green-400) or `↓ 8% vs previous period` (red-400)
      - If delta === 0 or previousValue === 0: don't show trend
    - Platform breakdown (optional):
      - Render as small inline badges below the trend: `flex flex-wrap gap-2 mt-2`
      - Each badge: `text-xs px-2 py-0.5 rounded-full bg-gray-800 text-gray-300`
      - Format: "12 Instagram", "5 TikTok" — capitalize platform name
    - Use `cn` from `@/lib/utils` for conditional classes

    2. Create `src/components/analytics/counter-card-skeleton.tsx`:

    Props: `{ count?: number }` (per DEV-022 skeleton count prop pattern)
    - Render `count` skeleton cards (default 1)
    - Each skeleton matches CounterCard dimensions:
      - Same container: `bg-surface border border-border rounded-sm p-4`
      - Skeleton line for label (h-4 w-32)
      - Skeleton line for value (h-8 w-24)
      - Skeleton line for trend (h-3 w-40)
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors.</verify>
  <done>CounterCard renders value with trend delta and optional platform breakdown. CounterCardSkeleton matches card dimensions.</done>
</task>

<task type="auto">
  <name>Task 2: Create TimeRangeSelector toggle component</name>
  <files>src/components/analytics/time-range-selector.tsx</files>
  <action>
    Create `src/components/analytics/time-range-selector.tsx`:

    Props interface:
    ```typescript
    import type { TimeRange } from '@/types/analytics'

    interface TimeRangeSelectorProps {
      value: TimeRange
      onChange: (range: TimeRange) => void
      className?: string
    }
    ```

    Implementation:
    - Container: `inline-flex rounded-sm border border-border bg-surface` (pill toggle group)
    - Three buttons: "7d", "30d", "90d" mapping to TimeRange values 7, 30, 90
    - Active button: `bg-accent-purple text-white` (consistent with sidebar active state)
    - Inactive button: `text-gray-400 hover:text-white hover:bg-surface/50`
    - Each button: `px-3 py-1.5 text-sm font-medium transition-colors`
    - First button gets `rounded-l-sm`, last gets `rounded-r-sm`
    - onClick calls `onChange` with the corresponding TimeRange value
    - Component is a controlled component (value + onChange from parent)

    Note: TimeRange type comes from `@/types/analytics` which is created in Plan 01 (Wave 1). Since both plans are Wave 1, the type file may not exist yet. Import it anyway — TypeScript will resolve once both plans complete. Alternatively, define `type TimeRange = 7 | 30 | 90` locally if needed for independent execution.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors (may need Plan 01 to complete first for type import).</verify>
  <done>TimeRangeSelector renders 7d/30d/90d toggle buttons. Active state visually highlighted. Controlled via value/onChange props.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- CounterCard renders with trend indicator (positive green, negative red)
- CounterCardSkeleton renders matching dimensions
- TimeRangeSelector renders three toggle buttons with active state
</verification>

<success_criteria>
Counter cards and time range selector ready for page assembly. Components are self-contained with proper loading states.
</success_criteria>

<output>
After completion, create `.planning/phases/06-analytics/06-02-SUMMARY.md`
</output>
