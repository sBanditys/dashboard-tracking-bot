---
phase: 15-reactivate-nextjs-middleware
plan: 02
type: execute
wave: 2
depends_on:
  - 15-01
files_modified:
  - playwright.config.ts
  - e2e/security-headers.spec.ts
  - e2e/csrf-cookie.spec.ts
  - e2e/auth-redirect.spec.ts
  - package.json
autonomous: true
requirements:
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "Playwright is installed and configured for the project"
    - "E2E tests verify CSP header presence and nonce on public routes"
    - "E2E tests verify _csrf_token cookie is set on page load"
    - "E2E tests verify auth redirect to /?returnTo= for unauthenticated protected routes"
    - "E2E tests verify HSTS, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy headers"
    - "E2E tests verify X-Request-ID header is present on all responses"
    - "E2E tests cover all major app routes (public, auth, dashboard)"
    - "All E2E tests pass against running dev server"
  artifacts:
    - path: "playwright.config.ts"
      provides: "Playwright configuration for E2E testing"
      contains: "defineConfig"
    - path: "e2e/security-headers.spec.ts"
      provides: "CSP and security header verification tests for all routes"
      contains: "Content-Security-Policy"
    - path: "e2e/csrf-cookie.spec.ts"
      provides: "CSRF cookie presence and properties tests"
      contains: "_csrf_token"
    - path: "e2e/auth-redirect.spec.ts"
      provides: "Auth redirect behavior tests"
      contains: "returnTo"
  key_links:
    - from: "playwright.config.ts"
      to: "e2e/*.spec.ts"
      via: "testDir: ./e2e"
      pattern: "testDir.*e2e"
    - from: "e2e/security-headers.spec.ts"
      to: "src/middleware.ts"
      via: "verifies CSP/security headers set by middleware"
      pattern: "Content-Security-Policy"
    - from: "e2e/csrf-cookie.spec.ts"
      to: "src/middleware.ts"
      via: "verifies _csrf_token cookie set by middleware"
      pattern: "_csrf_token"
---

<objective>
Install Playwright and create E2E tests that verify middleware activation: CSP headers, CSRF cookies, security headers, and auth redirects across all app routes.

Purpose: Per locked decision, automated E2E tests must verify CSP does not break functionality and cover all routes. This validates that the middleware activation from Plan 01 is working correctly at the HTTP level.

Output: Playwright config, E2E test suite covering security headers, CSRF cookies, and auth redirects.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-reactivate-nextjs-middleware/15-RESEARCH.md
@.planning/phases/15-reactivate-nextjs-middleware/15-01-SUMMARY.md
@src/middleware.ts
@src/lib/server/security-headers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Playwright and configure E2E test infrastructure</name>
  <files>
    playwright.config.ts
    package.json
  </files>
  <action>
**Step 1: Install Playwright**

```bash
npm install --save-dev @playwright/test
npx playwright install chromium
```

Only install Chromium browser (not Firefox/WebKit) to keep install fast. Chromium covers the header verification needs.

**Step 2: Create playwright.config.ts**

Create `playwright.config.ts` at project root:

```typescript
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'list',
  use: {
    baseURL: 'http://localhost:3001',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3001',
    reuseExistingServer: !process.env.CI,
    timeout: 120_000,
  },
});
```

The port 3001 matches the project's dev server port (check package.json scripts or next.config for port). If the dev server uses a different port, adjust baseURL accordingly.

**Step 3: Add test script to package.json**

Add to package.json scripts:
```json
"test:e2e": "playwright test"
```

**Step 4: Add Playwright artifacts to .gitignore**

Check if `.gitignore` already has Playwright entries. If not, add:
```
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/
```
  </action>
  <verify>
1. `npx playwright --version` outputs version number
2. `playwright.config.ts` exists at project root
3. package.json has `test:e2e` script
4. .gitignore includes Playwright artifacts
  </verify>
  <done>
- Playwright installed as dev dependency
- Chromium browser installed for testing
- playwright.config.ts configured with localhost:3001, e2e test directory, chromium project
- package.json has test:e2e script
- .gitignore updated with Playwright artifacts
  </done>
</task>

<task type="auto">
  <name>Task 2: Write E2E tests for security headers, CSRF cookies, and auth redirects</name>
  <files>
    e2e/security-headers.spec.ts
    e2e/csrf-cookie.spec.ts
    e2e/auth-redirect.spec.ts
  </files>
  <action>
Create three E2E test files covering all routes. Since we cannot authenticate with Discord OAuth in tests, test strategy is:
- Public routes: Full header verification
- Protected routes: Verify redirect behavior and headers on the redirect response
- Auth routes: Verify headers on auth pages

**File 1: e2e/security-headers.spec.ts**

Tests CSP header and full security header suite on all route categories.

```typescript
import { test, expect } from '@playwright/test';

// Public routes that don't require auth
const PUBLIC_ROUTES = ['/', '/login', '/legal/terms', '/legal/privacy'];

// Protected routes that redirect unauthenticated users
const PROTECTED_ROUTES = ['/guilds', '/settings'];

// Auth routes accessible without authentication
const AUTH_ROUTES = ['/auth/unverified-email'];

test.describe('Security Headers', () => {
  for (const route of PUBLIC_ROUTES) {
    test(`CSP header present on ${route}`, async ({ page }) => {
      const response = await page.goto(route, { waitUntil: 'commit' });
      // Follow redirects - check final response
      const csp = response?.headers()['content-security-policy'];

      // /login and / may redirect but should have CSP on response
      if (response?.status() === 200) {
        expect(csp).toBeDefined();
        expect(csp).toContain("default-src 'self'");
        expect(csp).toContain('nonce-');
        expect(csp).toContain("'strict-dynamic'");
        expect(csp).toContain('https://fonts.gstatic.com');
        expect(csp).toContain('wss:');
        expect(csp).toContain('report-uri /api/csp-report');
        expect(csp).toContain("frame-ancestors 'none'");
        expect(csp).toContain("object-src 'none'");
        expect(csp).toContain("upgrade-insecure-requests");
      }
    });

    test(`X-Frame-Options header on ${route}`, async ({ page }) => {
      const response = await page.goto(route, { waitUntil: 'commit' });
      if (response?.status() === 200) {
        expect(response?.headers()['x-frame-options']).toBe('DENY');
      }
    });

    test(`X-Content-Type-Options header on ${route}`, async ({ page }) => {
      const response = await page.goto(route, { waitUntil: 'commit' });
      if (response?.status() === 200) {
        expect(response?.headers()['x-content-type-options']).toBe('nosniff');
      }
    });

    test(`Referrer-Policy header on ${route}`, async ({ page }) => {
      const response = await page.goto(route, { waitUntil: 'commit' });
      if (response?.status() === 200) {
        expect(response?.headers()['referrer-policy']).toBe('strict-origin-when-cross-origin');
      }
    });

    test(`Permissions-Policy header on ${route}`, async ({ page }) => {
      const response = await page.goto(route, { waitUntil: 'commit' });
      if (response?.status() === 200) {
        const pp = response?.headers()['permissions-policy'];
        expect(pp).toBeDefined();
        expect(pp).toContain('geolocation=()');
        expect(pp).toContain('camera=()');
        expect(pp).toContain('microphone=()');
      }
    });

    test(`X-Request-ID header on ${route}`, async ({ page }) => {
      const response = await page.goto(route, { waitUntil: 'commit' });
      const requestId = response?.headers()['x-request-id'];
      expect(requestId).toBeDefined();
      // Should be a UUID format
      expect(requestId).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
    });
  }

  // Protected routes return redirect responses - verify headers on redirect
  for (const route of PROTECTED_ROUTES) {
    test(`Security headers on redirect for ${route}`, async ({ request }) => {
      // Use API request context to avoid following redirects
      const response = await request.get(route, { maxRedirects: 0 });
      // Should redirect (302/307)
      expect([301, 302, 307, 308]).toContain(response.status());

      // X-Request-ID should be on redirects too
      const requestId = response.headers()['x-request-id'];
      expect(requestId).toBeDefined();
    });
  }

  test('CSP nonce is unique per request', async ({ page }) => {
    const response1 = await page.goto('/login', { waitUntil: 'commit' });
    const csp1 = response1?.headers()['content-security-policy'] ?? '';
    const nonce1 = csp1.match(/nonce-([A-Za-z0-9+/=]+)/)?.[1];

    const response2 = await page.goto('/login', { waitUntil: 'commit' });
    const csp2 = response2?.headers()['content-security-policy'] ?? '';
    const nonce2 = csp2.match(/nonce-([A-Za-z0-9+/=]+)/)?.[1];

    expect(nonce1).toBeDefined();
    expect(nonce2).toBeDefined();
    expect(nonce1).not.toBe(nonce2);
  });

  test('API routes do not have CSP header', async ({ request }) => {
    const response = await request.get('/api/auth/session');
    const csp = response.headers()['content-security-policy'];
    expect(csp).toBeUndefined();
  });

  test('API routes have non-CSP security headers', async ({ request }) => {
    const response = await request.get('/api/auth/session');
    expect(response.headers()['x-frame-options']).toBe('DENY');
    expect(response.headers()['x-content-type-options']).toBe('nosniff');
  });
});
```

**File 2: e2e/csrf-cookie.spec.ts**

Tests CSRF cookie is set correctly.

```typescript
import { test, expect } from '@playwright/test';

test.describe('CSRF Cookie', () => {
  test('_csrf_token cookie set on page load', async ({ page, context }) => {
    await page.goto('/login');
    const cookies = await context.cookies();
    const csrfCookie = cookies.find(c => c.name === '_csrf_token');

    expect(csrfCookie).toBeDefined();
    expect(csrfCookie?.httpOnly).toBe(false); // Client JS must read token
    expect(csrfCookie?.path).toBe('/');
    expect(csrfCookie?.sameSite).toBe('Lax');
  });

  test('_csrf_token cookie is a UUID', async ({ page, context }) => {
    await page.goto('/login');
    const cookies = await context.cookies();
    const csrfCookie = cookies.find(c => c.name === '_csrf_token');

    expect(csrfCookie?.value).toMatch(
      /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/
    );
  });

  test('_csrf_token rotates on each request', async ({ page, context }) => {
    await page.goto('/login');
    const cookies1 = await context.cookies();
    const token1 = cookies1.find(c => c.name === '_csrf_token')?.value;

    await page.goto('/login');
    const cookies2 = await context.cookies();
    const token2 = cookies2.find(c => c.name === '_csrf_token')?.value;

    expect(token1).toBeDefined();
    expect(token2).toBeDefined();
    expect(token1).not.toBe(token2); // Per-request rotation
  });

  test('CSRF validation rejects mutation without token', async ({ request }) => {
    // POST to a non-auth API route without CSRF token should fail
    const response = await request.post('/api/guilds', {
      data: {},
      headers: { 'Content-Type': 'application/json' },
    });

    expect(response.status()).toBe(403);
    const body = await response.json();
    expect(body.code).toBe('EBADCSRFTOKEN');
  });
});
```

**File 3: e2e/auth-redirect.spec.ts**

Tests auth redirect behavior for unauthenticated users.

```typescript
import { test, expect } from '@playwright/test';

test.describe('Auth Redirects', () => {
  test('unauthenticated user on /guilds redirects to /?returnTo=/guilds', async ({ request }) => {
    const response = await request.get('/guilds', { maxRedirects: 0 });
    expect([301, 302, 307, 308]).toContain(response.status());

    const location = response.headers()['location'];
    expect(location).toBeDefined();
    // Should redirect to landing page with returnTo param
    expect(location).toContain('returnTo');
    expect(location).toContain('/guilds');
  });

  test('unauthenticated user on / redirects to /login (no returnTo)', async ({ request }) => {
    const response = await request.get('/', { maxRedirects: 0 });
    expect([301, 302, 307, 308]).toContain(response.status());

    const location = response.headers()['location'];
    expect(location).toBeDefined();
    // Landing page without returnTo should redirect to /login
    // Note: This tests the landing page component behavior, not middleware
  });

  test('landing page with returnTo redirects to login with callbackUrl', async ({ request }) => {
    // Simulate: middleware redirected to /?returnTo=/guilds/123
    const response = await request.get('/?returnTo=/guilds/123', { maxRedirects: 0 });
    expect([301, 302, 307, 308]).toContain(response.status());

    const location = response.headers()['location'];
    expect(location).toBeDefined();
    // Landing page should bridge returnTo → callbackUrl
    expect(location).toContain('/login');
    expect(location).toContain('callbackUrl');
    expect(location).toContain(encodeURIComponent('/guilds/123'));
  });

  test('/auth/unverified-email accessible without auth', async ({ page }) => {
    const response = await page.goto('/auth/unverified-email');
    // Should not redirect to login
    expect(response?.status()).toBe(200);
  });

  test('/legal/terms accessible without auth', async ({ page }) => {
    const response = await page.goto('/legal/terms');
    expect(response?.status()).toBe(200);
  });

  test('/legal/privacy accessible without auth', async ({ page }) => {
    const response = await page.goto('/legal/privacy');
    expect(response?.status()).toBe(200);
  });
});
```

**Important test design notes:**
- Tests use `maxRedirects: 0` on protected routes to inspect the redirect response itself
- Cannot test authenticated dashboard routes because Discord OAuth requires a real account
- HSTS is NOT tested because it's only set in production (`NODE_ENV === 'production'`), and tests run against dev server
- CSP header assertions check for the specific directives added in Plan 01
- Tests verify headers on the Playwright HTTP level, not DOM level, which is the correct level for middleware verification
  </action>
  <verify>
1. Run `npx playwright test` - all tests pass
2. Verify all three test files exist in `e2e/` directory
3. Tests cover: CSP header content, CSRF cookie properties, auth redirect behavior, security headers on all response types
  </verify>
  <done>
- E2E tests verify CSP header with nonce, fonts.gstatic.com, wss:, report-uri on public routes
- E2E tests verify _csrf_token cookie is set, non-HttpOnly, UUID format, rotates per-request
- E2E tests verify CSRF validation rejects mutations without token
- E2E tests verify auth redirect to /?returnTo= for protected routes
- E2E tests verify landing page bridges returnTo to login callbackUrl
- E2E tests verify security header suite (X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy)
- E2E tests verify X-Request-ID UUID on all responses
- E2E tests verify public/legal/auth routes accessible without auth
- All tests pass against dev server
  </done>
</task>

</tasks>

<verification>
1. `npx playwright test` - all E2E tests pass
2. Test coverage includes all major route categories: public, protected, auth, legal, API
3. Security headers verified: CSP (with nonce, fonts.gstatic.com, wss:, report-uri), X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy, X-Request-ID
4. CSRF cookie verified: set, non-HttpOnly, UUID, per-request rotation
5. Auth redirect chain verified: protected route → /?returnTo= → /login?callbackUrl=
</verification>

<success_criteria>
- Playwright installed and configured
- All E2E tests pass (security headers, CSRF cookies, auth redirects)
- Tests cover all app routes: public (/login, /legal/*), protected (/guilds, /settings), auth (/auth/*)
- CSP nonce uniqueness verified per request
- CSRF rejection verified for mutations without token
- No flaky tests (deterministic header/cookie checks)
</success_criteria>

<output>
After completion, create `.planning/phases/15-reactivate-nextjs-middleware/15-02-SUMMARY.md`
</output>
