---
phase: 08-polish-optimization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-persistent-state.ts
  - src/hooks/use-unsaved-changes.ts
  - src/hooks/use-sse.ts
autonomous: true

must_haves:
  truths:
    - "Filter state and search queries persist across browser back/forward navigation"
    - "Browser beforeunload triggers when user has unsaved form changes"
    - "SSE connections close when tab is hidden and reconnect when tab becomes visible"
  artifacts:
    - path: "src/hooks/use-persistent-state.ts"
      provides: "sessionStorage-backed state hook"
      exports: ["usePersistentState"]
    - path: "src/hooks/use-unsaved-changes.ts"
      provides: "beforeunload warning hook"
      exports: ["useUnsavedChanges"]
    - path: "src/hooks/use-sse.ts"
      provides: "SSE hook with tab visibility handling"
      contains: "visibilitychange"
  key_links:
    - from: "src/hooks/use-persistent-state.ts"
      to: "sessionStorage"
      via: "getItem/setItem"
      pattern: "sessionStorage"
    - from: "src/hooks/use-sse.ts"
      to: "document.visibilitychange"
      via: "event listener"
      pattern: "visibilitychange"
---

<objective>
Create hooks for state persistence (sessionStorage), unsaved changes detection (beforeunload), and add tab visibility handling to the existing SSE hook.

Purpose: Browser state preservation and connection lifecycle management — users don't lose filters on back/forward, get warned about unsaved changes, and SSE connections don't leak across tabs.
Output: usePersistentState hook, useUnsavedChanges hook, enhanced useSSE with visibility handling.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-polish-optimization/08-RESEARCH.md

@src/hooks/use-sse.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePersistentState and useUnsavedChanges hooks</name>
  <files>
    src/hooks/use-persistent-state.ts
    src/hooks/use-unsaved-changes.ts
  </files>
  <action>
    1. Create `src/hooks/use-persistent-state.ts`:
       - 'use client' hook
       - Generic function: `usePersistentState<T>(key: string, defaultValue: T): [T, (value: T | ((prev: T) => T)) => void]`
       - Initialize state from sessionStorage: try to parse stored JSON, fall back to defaultValue
       - Guard against SSR: check `typeof window !== 'undefined'` before accessing sessionStorage
       - On state change, write to sessionStorage via useEffect
       - Support function updater pattern (like React useState)
       - Handle JSON parse errors gracefully (return defaultValue)

    2. Create `src/hooks/use-unsaved-changes.ts`:
       - 'use client' hook
       - Function: `useUnsavedChanges(hasUnsavedChanges: boolean): void`
       - Add beforeunload event listener when hasUnsavedChanges is true
       - In handler: e.preventDefault(), e.returnValue = '' (required for Chrome)
       - Clean up listener on unmount or when hasUnsavedChanges becomes false
       - Note in comment: Next.js App Router doesn't expose beforeRouteChange events, so this covers browser navigation (refresh, close tab, external navigation) but not internal Link navigation. This is the recommended approach per research.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Both hooks export correctly with proper TypeScript generics
  </verify>
  <done>
    usePersistentState hook persists generic state to sessionStorage with SSR safety. useUnsavedChanges hook triggers browser beforeunload dialog when form has unsaved changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tab visibility handling to SSE hook</name>
  <files>
    src/hooks/use-sse.ts
  </files>
  <action>
    Update the existing `useSSE` hook to handle tab visibility changes:

    1. Add a new useEffect that listens to `document.visibilitychange`:
       - When `document.hidden` becomes true: close the EventSource, set state to 'disconnected'
       - When `document.hidden` becomes false AND url is not null: call `connect()` to reestablish SSE
       - Clean up the event listener on unmount

    2. Place this AFTER the existing connect useEffect (so it can reference connect and eventSourceRef)

    3. Also clear any pending retry timeout when closing on visibility change (use retryTimeoutRef)

    4. Don't change any existing functionality — just add the visibility handling as an additional effect

    This prevents SSE connection leaks when users have multiple tabs open. When tab is hidden, connection is closed. When tab becomes visible again, it reconnects with a fresh connection.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - useSSE still exports connectionState and reconnect
    - New visibilitychange listener is added in a useEffect
    - Existing connect/reconnect logic unchanged
  </verify>
  <done>
    SSE hook closes connection when tab is hidden, reconnects when tab becomes visible. Prevents connection leaks from multiple open tabs.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- usePersistentState, useUnsavedChanges both export correctly
- useSSE has visibilitychange handler
</verification>

<success_criteria>
- usePersistentState reads/writes sessionStorage with SSR safety and generic typing
- useUnsavedChanges triggers beforeunload when hasUnsavedChanges is true
- SSE connections close on tab hide, reconnect on tab visible
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-polish-optimization/08-03-SUMMARY.md`
</output>
