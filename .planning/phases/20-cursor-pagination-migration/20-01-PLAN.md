---
phase: 20-cursor-pagination-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/tracking.ts
  - src/hooks/use-tracking.ts
  - src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx
  - src/app/(dashboard)/guilds/[guildId]/posts/page.tsx
autonomous: true
requirements:
  - PAGE-01
  - PAGE-02

must_haves:
  truths:
    - "useAccountsInfinite sends cursor query param instead of page number"
    - "usePostsInfinite sends cursor query param instead of page number"
    - "getNextPageParam returns undefined (not null) when has_more is false"
    - "AccountsResponse and PostsResponse use next_cursor/has_more instead of pagination object"
    - "Pagination interface no longer exists in tracking.ts"
    - "End-of-list message appears when no more items exist"
    - "Stale cursor error shows 'List has changed' with reset button"
  artifacts:
    - path: "src/types/tracking.ts"
      provides: "Cursor-based AccountsResponse and PostsResponse types"
      contains: "next_cursor"
    - path: "src/hooks/use-tracking.ts"
      provides: "Cursor-based useAccountsInfinite and usePostsInfinite hooks"
      contains: "initialPageParam: null"
    - path: "src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx"
      provides: "End-of-list and stale cursor UI for accounts"
      contains: "reached the end"
    - path: "src/app/(dashboard)/guilds/[guildId]/posts/page.tsx"
      provides: "End-of-list and stale cursor UI for posts"
      contains: "reached the end"
  key_links:
    - from: "src/hooks/use-tracking.ts"
      to: "src/types/tracking.ts"
      via: "imports AccountsResponse/PostsResponse"
      pattern: "import.*AccountsResponse.*PostsResponse.*from.*tracking"
    - from: "src/hooks/use-tracking.ts"
      to: "/api/guilds/{guildId}/accounts"
      via: "fetchWithRetry with cursor param"
      pattern: "params\\.set\\('cursor'"
---

<objective>
Migrate useAccountsInfinite and usePostsInfinite hooks from offset-based to cursor-based pagination, update TypeScript types to cursor-only shape, and add end-of-list and stale cursor UI to both list pages.

Purpose: Match the backend's cursor-based pagination API (Phase 39) — accounts and posts lists will send cursor tokens instead of page numbers.
Output: Cursor-based infinite hooks, updated types, and refined page UI with end-of-list and stale cursor handling.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-cursor-pagination-migration/20-RESEARCH.md

@src/types/tracking.ts
@src/types/bonus.ts
@src/hooks/use-tracking.ts
@src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx
@src/app/(dashboard)/guilds/[guildId]/posts/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate types and infinite hooks to cursor pagination</name>
  <files>
    src/types/tracking.ts
    src/hooks/use-tracking.ts
  </files>
  <action>
**In src/types/tracking.ts:**

1. Delete the `Pagination` interface entirely (lines 5-10).
2. Add a `CursorPagination` interface mirroring the existing `BonusRoundsResponse` pattern in `src/types/bonus.ts`:
   ```typescript
   export interface CursorPagination {
       next_cursor: string | null
       has_more: boolean
   }
   ```
3. Update `AccountsResponse` to use cursor fields (not a nested `pagination` object):
   ```typescript
   export interface AccountsResponse {
       accounts: Account[]
       next_cursor: string | null
       has_more: boolean
   }
   ```
4. Update `PostsResponse` the same way:
   ```typescript
   export interface PostsResponse {
       posts: Post[]
       next_cursor: string | null
       has_more: boolean
   }
   ```
5. Delete the `useAccounts` function (non-infinite offset-based hook at line 34-47) — it is not imported by any page component (grep confirms only `use-tracking.ts` defines it). Similarly, delete `usePosts` (non-infinite offset hook at lines 71-90) if it is not imported elsewhere.
6. Delete the `buildPostQuery` function (lines 52-66) — it was used only by `usePosts` which is being removed.

**In src/hooks/use-tracking.ts:**

7. Update `buildAccountQuery` to accept a cursor parameter instead of page:
   ```typescript
   function buildAccountQuery(cursor: string | null, limit: number, filters: AccountFilters): string {
       const params = new URLSearchParams()
       params.set('limit', limit.toString())
       if (cursor) params.set('cursor', cursor)
       if (filters.search) params.set('search', filters.search)
       if (filters.platform) params.set('platform', filters.platform)
       if (filters.group) params.set('group', filters.group)
       return params.toString()
   }
   ```

8. Update `useAccountsInfinite`:
   - Change `initialPageParam: 1` to `initialPageParam: null as string | null`
   - Update `getNextPageParam` from offset logic to:
     ```typescript
     getNextPageParam: (lastPage) =>
         lastPage.has_more ? lastPage.next_cursor : undefined,
     ```
   - The `queryFn` already passes `pageParam` to `buildAccountQuery` — with the new signature this will pass `null` on first load (no cursor sent) and the cursor string on subsequent pages.
   - Add stale cursor detection in the queryFn: if response status is 400 or 422, throw an error with `code: 'CURSOR_INVALID'`:
     ```typescript
     if (response.status === 400 || response.status === 422) {
         const err = new Error('Cursor expired or invalid')
         ;(err as Error & { code: string }).code = 'CURSOR_INVALID'
         throw err
     }
     ```
   - Set `retry: 2` on the query options (auto-retry 2 times per user decision on next-page fetch failures; React Query retries by default but being explicit matches the locked decision of "2-3 times").

9. Update `buildPostQueryExtended` the same way — replace `page: number` with `cursor: string | null`, remove `params.set('page', ...)`, add conditional `params.set('cursor', cursor)`.

10. Update `usePostsInfinite` identically to `useAccountsInfinite`:
    - `initialPageParam: null as string | null`
    - Same `getNextPageParam` using `has_more` and `next_cursor`
    - Same stale cursor detection (400/422)
    - `retry: 2`
  </action>
  <verify>
    <automated>cd /Users/gabrielleal/Desktop/dashboard-tracking-bot && npx tsc --noEmit 2>&1 | head -40</automated>
    <manual>Verify tracking.ts no longer exports Pagination, and AccountsResponse/PostsResponse use next_cursor/has_more</manual>
  </verify>
  <done>
    - Pagination interface deleted from tracking.ts
    - CursorPagination interface added
    - AccountsResponse and PostsResponse use next_cursor/has_more (flat, not nested)
    - useAccountsInfinite and usePostsInfinite use initialPageParam: null, cursor-based getNextPageParam
    - Query builders send cursor param instead of page param
    - Stale cursor detection throws CURSOR_INVALID error on 400/422
    - useAccounts and usePosts (non-infinite) removed if unused
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add end-of-list message and stale cursor UI to page components</name>
  <files>
    src/app/(dashboard)/guilds/[guildId]/accounts/page.tsx
    src/app/(dashboard)/guilds/[guildId]/posts/page.tsx
  </files>
  <action>
**In accounts/page.tsx:**

1. Add import for `useQueryClient` from `@tanstack/react-query`.

2. Add `const queryClient = useQueryClient()` in the component body.

3. Destructure `error` from `useAccountsInfinite` (currently not destructured).

4. Add a stale cursor detection check:
   ```typescript
   const isCursorInvalid = isError && (error as Error & { code?: string })?.code === 'CURSOR_INVALID'
   ```

5. After the sentinel div (`<div ref={ref} className="h-1" />`), after the loading-more skeleton block, and before `<ScrollToTop />`, add:

   a. **End-of-list message** — shown when data is loaded, has items, but no more pages:
   ```tsx
   {!isLoading && data && !hasNextPage && accounts.length > 0 && (
       <p className="text-center py-4 text-sm text-gray-500">You've reached the end</p>
   )}
   ```

   b. **Stale cursor UI** — shown when a cursor-invalid error occurs on fetchNextPage:
   ```tsx
   {isCursorInvalid && (
       <div className="text-center py-4 space-y-2">
           <p className="text-sm text-gray-400">List has changed.</p>
           <button
               type="button"
               onClick={() => {
                   queryClient.resetQueries({ queryKey: ['guild', guildId, 'accounts'] })
               }}
               className="text-sm text-accent-purple hover:text-accent-purple/80 transition-colors"
           >
               Refresh from start
           </button>
       </div>
   )}
   ```

6. The existing `isFetchingNextPage` skeleton already uses `AccountCardSkeleton` for skeleton rows per the locked decision — no change needed there.

**In posts/page.tsx:**

7. Apply the exact same additions: import `useQueryClient`, add `queryClient`, extract `isCursorInvalid`, add end-of-list message and stale cursor UI after the loading-more skeleton block and before `<ScrollToTop />`. Use `['guild', guildId, 'posts']` as the query key for the reset button.

8. The posts page already destructures `error` — just add the `isCursorInvalid` check.
  </action>
  <verify>
    <automated>cd /Users/gabrielleal/Desktop/dashboard-tracking-bot && npx tsc --noEmit 2>&1 | head -40</automated>
    <manual>Verify accounts and posts pages both show "You've reached the end" text and have a "Refresh from start" button for cursor errors</manual>
  </verify>
  <done>
    - Both pages show "You've reached the end" when hasNextPage is false and items exist
    - Both pages detect CURSOR_INVALID error and show "List has changed" + "Refresh from start" reset button
    - Stale cursor reset button calls queryClient.resetQueries to restart from first page
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no TypeScript compilation errors
2. `Pagination` interface no longer exists in src/types/tracking.ts
3. `AccountsResponse` and `PostsResponse` have `next_cursor: string | null` and `has_more: boolean`
4. `useAccountsInfinite` uses `initialPageParam: null` and `getNextPageParam` returns `undefined` when `has_more` is false
5. `usePostsInfinite` uses the same cursor pattern
6. Both pages have end-of-list and stale cursor UI elements
7. No references to `page` parameter in query builders for infinite queries
</verification>

<success_criteria>
- TypeScript compiles cleanly with the new cursor-only types
- Infinite hooks use cursor param instead of page param
- End-of-list and stale cursor UI present on both pages
- No dead code (offset-based useAccounts/usePosts removed if unused)
</success_criteria>

<output>
After completion, create `.planning/phases/20-cursor-pagination-migration/20-01-SUMMARY.md`
</output>
