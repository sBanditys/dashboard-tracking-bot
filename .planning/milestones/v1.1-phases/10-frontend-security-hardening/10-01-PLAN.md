---
phase: 10-frontend-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/middleware.ts
  - src/lib/fetch-with-retry.ts
autonomous: true

must_haves:
  truths:
    - "All POST/PUT/PATCH/DELETE requests include a CSRF token via double-submit cookie pattern"
    - "CSRF token failure triggers a silent retry with a fresh token -- user never sees the initial failure"
    - "Auth routes (login, callback, refresh, logout) are excluded from CSRF validation"
    - "GET/HEAD/OPTIONS requests are not subject to CSRF validation"
  artifacts:
    - path: "src/middleware.ts"
      provides: "CSRF middleware integration using @edge-csrf/nextjs"
      contains: "createCsrfMiddleware\\|csrfProtect"
    - path: "src/lib/fetch-with-retry.ts"
      provides: "CSRF token injection for mutation requests + silent retry on CSRF failure"
      contains: "X-CSRF-Token"
  key_links:
    - from: "src/lib/fetch-with-retry.ts"
      to: "src/middleware.ts"
      via: "CSRF token cookie set by middleware, read by fetchWithRetry, sent as X-CSRF-Token header"
      pattern: "csrf.*cookie|X-CSRF-Token"
---

<objective>
Implement CSRF protection using the double-submit cookie pattern for all mutation requests.

Purpose: Prevent cross-site request forgery attacks (AUTH-03). All state-changing requests (POST, PUT, PATCH, DELETE) must include a CSRF token. CSRF failures are silently retried with a fresh token so users never see CSRF errors.

Output: Updated middleware.ts with @edge-csrf/nextjs integration, updated fetchWithRetry.ts with CSRF token injection and silent retry logic.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-frontend-security-hardening/10-CONTEXT.md
@.planning/phases/10-frontend-security-hardening/10-RESEARCH.md
@src/middleware.ts
@src/lib/fetch-with-retry.ts
@src/app/api/auth/refresh/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @edge-csrf/nextjs and integrate CSRF validation into middleware</name>
  <files>src/middleware.ts, package.json</files>
  <action>
Install @edge-csrf/nextjs (version 2.5.2 -- use stable, NOT the cloudflare RC):
```bash
npm install @edge-csrf/nextjs@2.5.2
```

Update `src/middleware.ts` to integrate CSRF protection using @edge-csrf/nextjs:

1. Import `createCsrfMiddleware` from `@edge-csrf/nextjs` (or the appropriate API for Next.js 14 -- check the library docs; it may be `createCsrfProtect` or `CsrfError`).

2. Create CSRF middleware configuration:
   - Use per-session tokens (not per-request) to avoid race conditions with concurrent mutations.
   - Cookie name: `_csrf_token` (NOT `__Host-` prefix since that requires Secure + no Domain + Path=/ which complicates local dev on Next.js 14).
   - Cookie options: `secure: process.env.NODE_ENV === 'production'`, `sameSite: 'lax'`, `httpOnly: false` (client JS must read the token to send in header).
   - Token header name: `X-CSRF-Token`.

3. Integrate CSRF into the existing middleware function:
   - CSRF validation should run BEFORE the existing auth redirect logic.
   - Exclude paths from CSRF: `/api/auth/*` (login, callback, refresh, logout all need exemption since they're part of the OAuth flow and auth lifecycle).
   - Exclude static assets and prefetch requests (already excluded by matcher config).
   - For API routes that are NOT auth routes: validate CSRF on mutation methods (POST, PUT, PATCH, DELETE).
   - For page routes (non-API): skip CSRF validation (only API mutations need it).

4. On CSRF validation failure: return 403 with JSON body `{ error: "Invalid CSRF token", code: "EBADCSRFTOKEN" }` so fetchWithRetry can detect and retry.

5. Ensure the CSRF token cookie is set on ALL responses (including page loads and GET requests) so the token is available before the first mutation. The @edge-csrf/nextjs library handles this automatically by setting the cookie on the response.

6. Keep the existing auth redirect logic (dashboard route protection, login redirect for authenticated users, /auth/* passthrough) intact. The CSRF layer wraps around it.

IMPORTANT: This project is on Next.js 14, which uses `middleware.ts` (NOT `proxy.ts` which is Next.js 16). The research mentions proxy.ts but that does NOT apply here.

IMPORTANT: The @edge-csrf/nextjs library API may differ from the research code examples. Check the actual library exports. The library typically exports `createCsrfProtect` and `CsrfError` for App Router usage (not `createCsrfMiddleware`). Consult the package README or types to confirm the correct API.
  </action>
  <verify>
1. `npm run build` completes without errors.
2. Start dev server (`npm run dev`) and verify:
   - Page loads set a `_csrf_token` cookie (check browser DevTools > Application > Cookies).
   - GET requests to API routes succeed without CSRF token.
   - A POST/PATCH/DELETE request WITHOUT `X-CSRF-Token` header returns 403 with `{ code: "EBADCSRFTOKEN" }`.
   - Auth routes (`/api/auth/*`) are accessible without CSRF token.
  </verify>
  <done>
CSRF middleware is active: mutation requests without valid CSRF token are rejected with 403, auth routes are exempt, and CSRF cookie is set on every response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CSRF token injection and silent retry to fetchWithRetry</name>
  <files>src/lib/fetch-with-retry.ts</files>
  <action>
Update `src/lib/fetch-with-retry.ts` to automatically inject CSRF tokens and silently retry on CSRF failures:

1. Add a helper function `getCsrfToken()` that reads the `_csrf_token` cookie from `document.cookie`:
   ```typescript
   function getCsrfToken(): string | undefined {
     if (typeof document === 'undefined') return undefined;
     return document.cookie
       .split('; ')
       .find(row => row.startsWith('_csrf_token='))
       ?.split('=')[1];
   }
   ```

2. Add a constant for mutation methods that require CSRF:
   ```typescript
   const CSRF_METHODS = new Set(['POST', 'PUT', 'PATCH', 'DELETE']);
   ```

3. In the `fetchWithRetry` function, BEFORE making the fetch call (inside the for loop, before `const response = await fetch(url, options)`):
   - Check if the request method is in CSRF_METHODS.
   - If it is AND the URL is NOT an auth endpoint (`isAuthEndpoint(url)` already exists), inject the CSRF token:
     - Read token via `getCsrfToken()`.
     - If token exists, create new headers with `X-CSRF-Token` set.
     - Modify the options to include the updated headers.
   - Use a mutable headers approach: create `Headers` from `options?.headers`, set the token, pass to fetch.

4. Add CSRF retry logic AFTER the existing 401 handling block and BEFORE the existing 403 unverified_email block:
   - When response is 403, clone and parse the body to check for `code: "EBADCSRFTOKEN"`.
   - If CSRF error detected AND we haven't already retried for CSRF:
     - Make a lightweight GET request to any page route (e.g., `fetch('/api/auth/session', { method: 'GET' })`) to trigger middleware and refresh the CSRF cookie.
     - Wait briefly (100ms) for cookie to propagate.
     - Set a flag `didRetryAfterCsrf = true` and `continue` (retry the loop with fresh token).
   - Per user decision: user never sees the initial CSRF failure (silent retry).
   - If retry also fails with CSRF error: show error toast "Session error, please refresh the page" (persistent CSRF failure escalation -- Claude's discretion: toast is less disruptive than force re-login).

5. Declare `let didRetryAfterCsrf = false;` alongside existing `let didRetryAfterRefresh = false;`.

6. The CSRF retry should NOT count against `maxRetries` (it's a separate concern). Use the same pattern as the 401 refresh retry: check flag, retry once, continue.

IMPORTANT: Do NOT modify the singleton `refreshPromise` pattern or any existing retry logic. CSRF retry is additive.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no type errors.
2. `npm run build` completes successfully.
3. Manual test flow:
   - Load a page in the dashboard (CSRF cookie gets set).
   - Trigger a mutation (e.g., update settings) -- should succeed (CSRF token auto-injected).
   - Manually delete the `_csrf_token` cookie in DevTools, trigger a mutation -- should silently retry and succeed (cookie refreshed via GET request).
  </verify>
  <done>
fetchWithRetry automatically injects X-CSRF-Token header on all mutation requests and silently retries once on CSRF token failure. Users never see CSRF-related errors during normal usage.
  </done>
</task>

</tasks>

<verification>
- All mutation API requests include X-CSRF-Token header automatically.
- CSRF token cookie is set on page loads and GET requests.
- Auth routes (/api/auth/*) are excluded from CSRF validation.
- CSRF failure triggers silent retry with fresh token.
- Existing auth flow (401 refresh, session recovery, unverified email redirect) is unaffected.
- `npm run build` passes.
</verification>

<success_criteria>
1. POST/PUT/PATCH/DELETE requests to non-auth API routes are rejected without valid CSRF token (403 + EBADCSRFTOKEN code).
2. fetchWithRetry automatically attaches CSRF token from cookie to mutation requests.
3. On CSRF failure, fetchWithRetry silently refreshes token and retries -- user never sees the error.
4. Auth routes remain CSRF-exempt.
5. Build succeeds with no TypeScript errors.
</success_criteria>

<output>
After completion, create `.planning/phases/10-frontend-security-hardening/10-01-SUMMARY.md`
</output>
