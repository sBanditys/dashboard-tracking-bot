---
phase: 19-auth-hardening-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/server/backend-fetch.ts
autonomous: true
requirements:
  - AUTH-02

must_haves:
  truths:
    - "backendFetch auto-forwards auth_token cookie as Authorization Bearer when called from server context and no Authorization header is already set"
    - "Existing API routes that explicitly pass Authorization header are unaffected — no double-injection"
    - "Calling backendFetch from client context does not throw — the dynamic import guard silently skips cookie forwarding"
  artifacts:
    - path: "src/lib/server/backend-fetch.ts"
      provides: "Auto-forwarding auth_token cookie as Bearer header in SSR context"
      contains: "await import('next/headers')"
  key_links:
    - from: "src/lib/server/backend-fetch.ts"
      to: "next/headers cookies()"
      via: "dynamic import with try/catch"
      pattern: "import\\('next/headers'\\)"
---

<objective>
Add automatic auth_token cookie forwarding to backendFetch for SSR context.

Purpose: Enable server-rendered pages and route handlers to call backendFetch without manually extracting the auth_token cookie — the function auto-injects it as an Authorization: Bearer header when running in server context (Next.js App Router route handlers, Server Components).

Output: Modified backendFetch that auto-forwards the auth_token cookie when available and no Authorization header is explicitly set.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/server/backend-fetch.ts
@src/lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSR cookie auto-forwarding to backendFetch</name>
  <files>src/lib/server/backend-fetch.ts</files>
  <action>
Modify `backendFetch` in `src/lib/server/backend-fetch.ts` to auto-forward the `auth_token` cookie as `Authorization: Bearer {token}` when running in server context.

**Implementation:**

Before the existing `if (INTERNAL_SECRET)` block, add a new block that:

1. Checks `!headers.has('Authorization')` — if the caller already set an Authorization header, skip (prevents double-injection for existing routes).
2. Uses `try { const { cookies } = await import('next/headers'); ... } catch { /* not in server context */ }` to dynamically import `next/headers`.
3. Inside the try block: calls `const cookieStore = await cookies()`, reads `cookieStore.get('auth_token')?.value`, and if a token exists, sets `headers.set('Authorization', \`Bearer ${token}\`)`.
4. The catch block is intentionally empty — it fires when `backendFetch` is called from client context (which won't happen in practice since this file uses `crypto` which is Node-only, but the guard is defensive).

**Why dynamic import with try/catch (not static import):** `next/headers` throws at build time if imported in a module that could be bundled for client. Even though `backend-fetch.ts` is server-only in practice (it imports `crypto`), the dynamic import guard is the recommended defensive pattern.

**Why forward-only (not check-expiry-first):** The middleware (`proxy.ts`) already proactively refreshes the `auth_token` cookie before SSR page requests land. By the time an SSR route handler calls `backendFetch`, the cookie is already fresh. Checking expiry inside `backendFetch` would duplicate middleware logic. If the backend returns 401, the existing client-side `fetchWithRetry` 401 handler redirects to login with a return URL — the chain is already complete.

**Updated JSDoc:** Add a bullet point to the existing JSDoc: "Auto-forwards auth_token cookie as Authorization: Bearer header in SSR context when no Authorization header is explicitly set."

Do NOT modify any existing API routes — they already pass Authorization explicitly, and the `!headers.has('Authorization')` guard makes them backwards-compatible. Cleanup of redundant token extraction is a separate concern.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root — should pass with no errors.

Confirm the dynamic import guard is present:
```bash
grep -n "import('next/headers')" src/lib/server/backend-fetch.ts
```

Confirm the Authorization guard prevents double-injection:
```bash
grep -n "headers.has('Authorization')" src/lib/server/backend-fetch.ts
```
  </verify>
  <done>
backendFetch auto-forwards auth_token cookie as Authorization: Bearer header when called in server context, existing routes with explicit Authorization are unaffected, and TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no type errors introduced
2. `grep -rn "import('next/headers')" src/lib/server/backend-fetch.ts` shows the dynamic import
3. `grep -rn "headers.has('Authorization')" src/lib/server/backend-fetch.ts` shows the guard
4. The file still exports `backendFetch` with the same signature — no breaking API change
</verification>

<success_criteria>
- backendFetch reads auth_token cookie from next/headers in server context
- The !headers.has('Authorization') guard prevents double-injection
- Dynamic import try/catch prevents client-context errors
- TypeScript compiles cleanly
- No existing API routes modified
</success_criteria>

<output>
After completion, create `.planning/phases/19-auth-hardening-resilience/19-01-SUMMARY.md`
</output>
