---
phase: 09-authentication-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/Desktop/Tracking Data Bot/api/src/services/dashboard/discordOAuth.ts
  - ~/Desktop/Tracking Data Bot/api/src/services/dashboard/jwtService.ts
  - ~/Desktop/Tracking Data Bot/api/src/routes/dashboard/auth.ts
  - ~/Desktop/Tracking Data Bot/api/src/middleware/dashboardAuth.ts
autonomous: true

must_haves:
  truths:
    - "Discord OAuth requests email scope so verified status is available"
    - "User with unverified Discord email is rejected at login with error code unverified_email"
    - "User with unverified email is rejected on every authenticated request, not just login"
    - "JWT payload contains email_verified claim for middleware enforcement"
  artifacts:
    - path: "~/Desktop/Tracking Data Bot/api/src/services/dashboard/discordOAuth.ts"
      provides: "Email scope in OAuth URL, verified check in processOAuthCallback"
      contains: "email"
    - path: "~/Desktop/Tracking Data Bot/api/src/services/dashboard/jwtService.ts"
      provides: "email_verified field in JwtPayload"
      contains: "email_verified"
    - path: "~/Desktop/Tracking Data Bot/api/src/middleware/dashboardAuth.ts"
      provides: "Verified email check on every authenticated request"
      contains: "email_verified"
  key_links:
    - from: "discordOAuth.ts"
      to: "auth.ts callback"
      via: "processOAuthCallback returns null or error for unverified"
      pattern: "verified.*false|unverified"
    - from: "dashboardAuth.ts"
      to: "jwtService.ts"
      via: "reads email_verified from JWT payload"
      pattern: "email_verified"
---

<objective>
Add verified email enforcement to the backend authentication system. Discord OAuth must request the `email` scope, check the user's verified status, and reject unverified users both at login and on every authenticated request.

Purpose: AUTH-02 requires that users with unverified Discord emails cannot access the dashboard. This protects against bot accounts and ensures account ownership.
Output: Backend rejects unverified email users at OAuth callback with `unverified_email` error code, and rejects them on every authenticated request via middleware.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@~/Desktop/Tracking Data Bot/api/src/services/dashboard/discordOAuth.ts
@~/Desktop/Tracking Data Bot/api/src/services/dashboard/jwtService.ts
@~/Desktop/Tracking Data Bot/api/src/routes/dashboard/auth.ts
@~/Desktop/Tracking Data Bot/api/src/middleware/dashboardAuth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email scope and verified check to Discord OAuth flow</name>
  <files>
    ~/Desktop/Tracking Data Bot/api/src/services/dashboard/discordOAuth.ts
    ~/Desktop/Tracking Data Bot/api/src/routes/dashboard/auth.ts
  </files>
  <action>
    In `discordOAuth.ts`:
    1. Add `email` to the OAuth scope string: change `scope: 'identify guilds'` to `scope: 'identify guilds email'` in `getAuthorizationUrl()`.
    2. Add `verified` field to the `DiscordUser` interface: `verified?: boolean`.
    3. In `processOAuthCallback()`, after fetching user and before `getAccessibleGuilds`, add a check:
       - If `user.verified === false`, return a specific rejection. Change the return type to include an error variant: `{ user, guilds } | { error: 'unverified_email' } | null`.
       - If `user.verified` is `false`, log a warning and return `{ error: 'unverified_email' }`.
       - Log: `logger.warn({ event: 'oauth_unverified_email', userId: user.id }, 'User has unverified Discord email')`.

    In `auth.ts` (the OAuth callback handler `GET /discord/callback`):
    4. Update the `processOAuthCallback` result handling to check for the `unverified_email` error:
       - If result has `error === 'unverified_email'`, redirect to `${DASHBOARD_URL}/login?error=unverified_email`.
       - Distinguish from `null` result (which redirects to `oauth_failed`).

    NOTE: The `processOAuthCallback` return type should be updated to a discriminated union:
    ```typescript
    type OAuthCallbackResult =
      | { ok: true; user: DiscordUser; guilds: JwtGuildAccess[] }
      | { ok: false; error: 'unverified_email' }
      | null; // for other failures
    ```
    Or simpler: keep returning `null` for failures but throw a typed error for unverified email that the caller catches.

    Preferred approach: Return `{ error: 'unverified_email' }` from `processOAuthCallback` and check `'error' in result` in auth.ts callback.
  </action>
  <verify>
    Run TypeScript check: `npx tsc --noEmit -p "/Users/gabrielleal/Desktop/Tracking Data Bot/api/tsconfig.json"`
    Verify the OAuth URL includes `email` scope.
    Verify the callback handler redirects to login with `error=unverified_email` for unverified users.
  </verify>
  <done>
    OAuth authorization URL requests `identify guilds email` scope. processOAuthCallback rejects users where `verified !== true`. OAuth callback redirects to `/login?error=unverified_email` for unverified users.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add email_verified to JWT payload and enforce in middleware</name>
  <files>
    ~/Desktop/Tracking Data Bot/api/src/services/dashboard/jwtService.ts
    ~/Desktop/Tracking Data Bot/api/src/middleware/dashboardAuth.ts
    ~/Desktop/Tracking Data Bot/api/src/routes/dashboard/auth.ts
  </files>
  <action>
    Per user decision: "Check runs on every authenticated request, not just login" and "Enforcement applies to existing sessions too — unverified users are forced out on every request".

    In `jwtService.ts`:
    1. Add `email_verified: boolean` to the `JwtPayload` interface.
    2. In `createAccessToken`, ensure `email_verified` is included in the payload.
    3. In `createTokenPair`, accept `email_verified` in the user parameter: `user: { id: string; username: string; avatar?: string; email_verified: boolean }`.
    4. Pass `email_verified` through to `createAccessToken`.
    5. In `refreshTokens`, include `email_verified` in the `RefreshClaimSnapshot` interface (add field) and carry it through refresh rotation. Add it to `RefreshTokenClaimFallback` and `RefreshClaimSnapshot` interfaces.
    6. When creating access token in `refreshTokens`, include `email_verified: claimSnapshot.email_verified`.

    In `auth.ts`:
    7. In the OAuth callback handler, pass `email_verified: true` when calling `createTokenPair` (we already verified email in Task 1, so if we reach token creation, email is verified).
    8. In the `/me` endpoint, include `email_verified` in the response.

    In `dashboardAuth.ts`:
    9. In `requireDashboardAuth`, after successful token verification (after `req.dashboardUser = payload`), add a check:
       - If `payload.email_verified === false`, return 403 with `{ error: 'Forbidden', message: 'Email verification required', code: 'unverified_email' }`.
       - This enforces the check on EVERY authenticated request, catching users whose sessions were created before this enforcement was added.
       - Log: `logger.warn({ userId: payload.sub, event: 'unverified_email_blocked' }, 'Unverified email user blocked')`.
    10. Allow the check to pass if `email_verified` is `undefined` (backward compat for tokens issued before this change — those tokens will expire naturally within 1 hour since access tokens have 60min TTL).
       Actually, per the decision to force out existing sessions: if `email_verified` is NOT `true` (i.e., undefined or false), block access. This means existing tokens without the field will be rejected, forcing re-login where the email check will apply.

       HOWEVER: this would break all existing sessions immediately. Better approach: if `email_verified` is `undefined` (old token), allow access but log a warning. If explicitly `false`, block. This provides a graceful migration — old tokens expire within 60min, new tokens have the field.
  </action>
  <verify>
    Run TypeScript check: `npx tsc --noEmit -p "/Users/gabrielleal/Desktop/Tracking Data Bot/api/tsconfig.json"`
    Verify JwtPayload includes email_verified field.
    Verify requireDashboardAuth blocks requests where email_verified is explicitly false.
  </verify>
  <done>
    JwtPayload includes `email_verified` boolean. Token pair creation includes `email_verified`. Middleware rejects requests with `email_verified === false` with 403 and code `unverified_email`. Old tokens (undefined email_verified) are allowed through with a warning for graceful migration.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit -p "/Users/gabrielleal/Desktop/Tracking Data Bot/api/tsconfig.json"`
2. OAuth URL contains `scope=identify+guilds+email`
3. processOAuthCallback returns error for unverified users
4. JwtPayload type includes email_verified
5. requireDashboardAuth blocks email_verified=false with 403
6. createTokenPair passes email_verified through to access token
</verification>

<success_criteria>
- Backend rejects unverified email users at OAuth callback with clear error code
- Every authenticated request checks email_verified status in JWT
- Existing sessions without email_verified field continue working (graceful migration)
- All TypeScript types updated across the auth chain
</success_criteria>

<output>
After completion, create `.planning/phases/09-authentication-security/09-01-SUMMARY.md`
</output>
