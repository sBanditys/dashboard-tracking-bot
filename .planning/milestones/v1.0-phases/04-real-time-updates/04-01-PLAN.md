---
phase: 04-real-time-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/guilds/[guildId]/status/stream/route.ts
  - src/hooks/use-sse.ts
autonomous: true

must_haves:
  truths:
    - "SSE proxy route forwards events from backend"
    - "useSSE hook connects to SSE endpoint and manages reconnection"
    - "Connection state is exposed (connecting, connected, disconnected, error)"
  artifacts:
    - path: "src/app/api/guilds/[guildId]/status/stream/route.ts"
      provides: "SSE proxy route"
      exports: ["GET"]
      contains: "text/event-stream"
    - path: "src/hooks/use-sse.ts"
      provides: "Reusable SSE hook with reconnection"
      exports: ["useSSE"]
  key_links:
    - from: "src/app/api/guilds/[guildId]/status/stream/route.ts"
      to: "backend /api/v1/guilds/{guildId}/status/stream"
      via: "fetch with SSE headers"
      pattern: "Accept.*text/event-stream"
---

<objective>
Create SSE infrastructure for real-time bot status updates.

Purpose: Enable server-pushed status updates instead of polling, achieving sub-5-second latency for status changes.
Output: SSE proxy route and reusable useSSE hook with exponential backoff reconnection.
</objective>

<execution_context>
@/Users/gabrielleal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gabrielleal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-real-time-updates/04-CONTEXT.md
@.planning/phases/04-real-time-updates/04-RESEARCH.md

# Existing patterns to follow
@src/app/api/guilds/[guildId]/status/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE streaming proxy route</name>
  <files>src/app/api/guilds/[guildId]/status/stream/route.ts</files>
  <action>
Create an SSE proxy route that forwards the backend SSE stream to the client.

Requirements:
- Add `export const runtime = 'nodejs'` (required for streaming)
- Add `export const dynamic = 'force-dynamic'` (prevents caching)
- Read auth token from cookies (same pattern as existing status route)
- Fetch from backend `${API_URL}/api/v1/guilds/${guildId}/status/stream`
- Add `Accept: text/event-stream` header to backend request
- Return 401 if no auth token
- Return 502 if backend connection fails
- Forward backend response body as SSE stream with headers:
  - `Content-Type: text/event-stream`
  - `Cache-Control: no-cache, no-transform`
  - `Connection: keep-alive`
  - `X-Accel-Buffering: no` (for Nginx proxies)

Follow the exact pattern from 04-RESEARCH.md "SSE API Route" example.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/app/api/guilds/\[guildId\]/status/stream/route.ts
```
  </verify>
  <done>SSE proxy route exists at `/api/guilds/[guildId]/status/stream` with proper streaming headers and auth</done>
</task>

<task type="auto">
  <name>Task 2: Create useSSE hook with reconnection</name>
  <files>src/hooks/use-sse.ts</files>
  <action>
Create a reusable React hook for SSE connections with exponential backoff.

Hook interface:
```typescript
interface UseSSEOptions {
  onMessage: (data: unknown) => void
  onError?: () => void
  maxRetries?: number           // default: 3
  initialRetryDelay?: number    // default: 1000ms
  maxRetryDelay?: number        // default: 30000ms
}

type ConnectionState = 'connecting' | 'connected' | 'disconnected' | 'error'

function useSSE(url: string | null, options: UseSSEOptions): {
  connectionState: ConnectionState
  reconnect: () => void
}
```

Implementation requirements:
- Use native EventSource API
- Return `connectionState` for UI display
- Implement exponential backoff with 50% jitter on reconnection
- Reset retry count on successful connection
- After maxRetries, set state to 'error' and call onError
- Expose `reconnect()` function for manual retry (resets retry count)
- Properly cleanup EventSource in useEffect return
- Clear retry timeout on cleanup
- If url is null, don't connect (return 'disconnected' state)
- Parse event.data as JSON and pass to onMessage

Follow the exact pattern from 04-RESEARCH.md "Custom useSSE Hook" example.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit src/hooks/use-sse.ts
```
  </verify>
  <done>useSSE hook exports ConnectionState type and useSSE function with exponential backoff reconnection</done>
</task>

</tasks>

<verification>
- [ ] `src/app/api/guilds/[guildId]/status/stream/route.ts` exists with SSE headers
- [ ] `src/hooks/use-sse.ts` exports useSSE and ConnectionState
- [ ] Both files compile without TypeScript errors
- [ ] Route includes `runtime = 'nodejs'` and `dynamic = 'force-dynamic'`
- [ ] Hook implements exponential backoff with jitter
</verification>

<success_criteria>
SSE infrastructure is ready for integration:
- SSE proxy route correctly forwards backend stream with proper headers
- useSSE hook manages connection lifecycle with automatic reconnection
- Both components are independently testable and follow established patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-updates/04-01-SUMMARY.md`
</output>
